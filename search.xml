<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue内部运行机制]]></title>
    <url>%2F2018%2F12%2F20%2FVue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.Vue.js 运行机制全局概览 初始化及挂载在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。 template 模板编译compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。 ​ parse：会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。 ​ optimize：主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面 时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。 ​ generate：是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。 响应式这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。 Virtual DOMrender function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 123456789&#123; tag: &apos;div&apos;, /*说明这是一个div标签*/ children: [ /*存放该标签的子节点*/ &#123; tag: &apos;a&apos;, /*说明这是一个a标签*/ text: &apos;click me&apos; /*标签的内容*/ &#125; ]&#125; //渲染后 &lt;div&gt; &lt;a&gt;click me&lt;/a&gt; &lt;/div&gt; 更新视图在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。 那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。 2.响应式系统的基本原理Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「响应式系统」。 12345678/* Object.defineProperty obj: 目标对象 prop: 需要操作的目标对象的属性名 descriptor: 描述符 return value 传入对象*/Object.defineProperty(obj, prop, descriptor) 实现 observer（可观察的）使用Object.defineProperty使对象变成可观察的，这一步在 init 的阶段会进行初始化，对数据进行「响应式化」。通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程） 123456789function observer (value) &#123; if (!value || (typeof value !== &apos;object&apos;)) &#123; return; &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]); &#125;);&#125; 响应式系统的依赖收集追踪原理「依赖收集」会让 数据知道有哪些地方依赖我的数据，变化的时候需要通知它们。最终会形成数据与视图的一种对应关系，如下图。 订阅者 Dep订阅者 Dep的主要作用是用来存放 Watcher 观察者对象 123456789101112131415161718class Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs = []; &#125; /* 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作； */ addSub (sub) &#123; this.subs.push(sub); &#125; /* 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作 */ notify () &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;) &#125;&#125; 观察者 Watcher123456789101112class Watcher &#123; constructor () &#123; /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this; &#125; /* 更新视图的方法 */ update () &#123; console.log(&quot;视图更新啦～&quot;); &#125;&#125;Dep.target = null; 依赖收集接下来我们修改一下 defineReactive 以及 Vue 的构造函数，来完成依赖收集。 我们在闭包中增加了一个 Dep 类的对象，用来收集 Watcher 对象。在对象被「读」的时候，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果当该对象被「写」的时候，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。 123456789101112131415161718192021222324252627282930function defineReactive (obj, key, val) &#123; /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */ dep.addSub(Dep.target); return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */ dep.notify(); &#125; &#125;);&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); /* 在这里模拟render的过程，为了触发test属性的get函数 */ console.log(&apos;render~&apos;, this._data.test); &#125;&#125; 小结首先在 observer 的过程中会注册 get 方法，该方法用来进行「依赖收集」。在它的闭包中会有一个 Dep 对象，这个对象用来存放 Watcher 对象的实例。其实「依赖收集」的过程就是把 Watcher 实例存放到对应的 Dep 对象中去。get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）方法，在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。 这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个： ​ 1.触发 get 方法；​ 2.新建一个 Watcher 对象。这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」。其主要就是 get 进行「依赖收集」。set 通过观察者来更新视图。 3.数据状态更新时的差异 diff 及 patch 机制patch首先说一下 patch 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 patch 的过程，我们需要将他们进行比对。 diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。 这张图中的相同颜色的方块中的节点会进行比对，比对得到「差异」后将这些「差异」更新到视图上。因为只进行同层级的比对，所以十分高效。 patch 的过程1234567891011121314function patch (oldVnode, vnode, parentElm) &#123; if (!oldVnode) &#123; addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; else if (!vnode) &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); &#125; else &#123; if (sameVnode(oldVNode, vnode)) &#123; patchVnode(oldVNode, vnode); &#125; else &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; &#125;&#125; 因为 patch 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。 1.首先在 oldVnode（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 addVnodes 将这些节点批量添加到 parentElm 上。同理，在 vnode（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 removeVnodes 进行批量的节点删除即可。 2.当 oldVNode 与 vnode 都存在的时候，需要判断它们是否属于 sameVnode（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。 sameVnode只有当 key、 tag、 isComment（是否为注释节点）、 data同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改input类型，所以他们被视为不同类型）即可。 patchVnode：这个函数是在符合 sameVnode 的条件下触发的，所以会进行「比对」。 1234567891011121314151617181920212223242526272829303132333435function patchVnode (oldVnode, vnode) &#123; //1.在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉 if (oldVnode === vnode) &#123; return; &#125; //2.当新老 VNode 节点都是 isStatic（静态的），并且 key 相同时，只要将 componentInstance 与 elm 从老 VNode 节点“拿过来”即可。 if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123; vnode.elm = oldVnode.elm; vnode.componentInstance = oldVnode.componentInstance; return; &#125; const elm = vnode.elm = oldVnode.elm; const oldCh = oldVnode.children; const ch = vnode.children; //3.当新 VNode 节点是文本节点的时候，直接用 setTextContent 来设置 text if (vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text); &#125; else &#123; //4.新 VNode 节点是非文本节点当时候 if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123; //新老节点children都存在且不相同时 updateChildren(elm, oldCh, ch); //更新子节点 &#125; else if (ch) &#123; //只有 ch 存在的时候，如果old是文本节点则先将节点的文本清除，然后将 ch 批量插入到节点elm下。 if (oldVnode.text) nodeOps.setTextContent(elm, &apos;&apos;); addVnodes(elm, null, ch, 0, ch.length - 1); &#125; else if (oldCh) &#123; //当只有 oldch 存在时，说明需要将老节点通过 removeVnodes 全部清除 removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (oldVnode.text) &#123; //只有老节点是文本节点的时候，清除其节点文本内 nodeOps.setTextContent(elm, &apos;&apos;) &#125; &#125;&#125; updateChildren 首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。 接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) 4.批量异步更新DOM策略及 nextTick 原理12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; test: &apos;begin&apos; &#125;; &#125;, methods () &#123; handleClick () &#123; this.test = &apos;end&apos;; console.log(this.$refs.test.innerText);//打印的是“begin” &#125; &#125;&#125; 当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。 当异步执行update的时候，会调用queueWatcher函数。 Vue.js 在我们修改 data 中的数据后修改视图的过程：“setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图”。 Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象并不是立即更新视图，而会被 push 进一个队列 queue 中，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，id重复的Watcher不会被多次加入到queue中去。等待下一个tick时，这些Watch对象才会被遍历取出。在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。 使用Vue.js的global API的$nextTick方法，即可访问真实DOM节点更新后的数据 123456789methods () &#123; handleClick () &#123; this.test = &apos;end&apos;; this.$nextTick(() =&gt; &#123; console.log(this.$refs.test.innerText);//打印&quot;end&quot; &#125;); console.log(this.$refs.test.innerText);//打印“begin” &#125; &#125; 为什么要异步更新视图123456789101112export default &#123; data () &#123; return &#123; test: 0 &#125;; &#125;, created () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.test++; &#125; &#125;&#125; 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 nextTickVue.js 实现了一个 nextTick 函数，是一个立即执行函数,返回一个queueNextTick接口。 nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。 用 setTimeout 来模拟这个方法，首先定义一个 callbacks 数组用来存储 nextTick，在下一个 tick 处理这些回调函数之前，所有的 cb 都会被存在这个 callbacks 数组中。pending 是一个标记位，代表一个等待的状态。 setTimeout 会在 task 中创建一个事件 flushCallbacks ，flushCallbacks 则会在执行时将 callbacks 中的所有 cb 依次执行。 1234567891011121314151617181920let callbacks = [];let pending = false;function nextTick (cb) &#123; callbacks.push(cb); if (!pending) &#123; pending = true; setTimeout(flushCallbacks, 0); &#125;&#125;function flushCallbacks () &#123; pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; 第一个例子中，当我们将 number 增加 1000 次时，先将对应的 Watcher 对象给 push 进一个队列 queue 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？ 因为 number 执行 ++ 操作以后对应的 Watcher 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 Watcher 对象去修改界面，而是只需要执行一个 Watcher 对象，使其将界面上的 0 变成 1000 即可。 那么，我们就需要执行一个过滤的操作，同一个的 Watcher 在同一个 tick 的时候应该只被执行一次，也就是说队列 queue 中不应该出现重复的 Watcher 对象。 那么我们给 Watcher 对象起个名字吧～用 id 来标记每一个 Watcher 对象，让他们看起来“不太一样”。 实现 update 方法，在修改数据后由 Dep 来调用， 而 run 方法才是真正的触发 patch 更新视图的方法。 123456789101112131415161718192021222324252627282930313233let uid = 0;class Watcher &#123; constructor () &#123; this.id = ++uid; &#125; update () &#123; console.log(&apos;watch&apos; + this.id + &apos; update&apos;); queueWatcher(this); &#125; run () &#123; console.log(&apos;watch&apos; + this.id + &apos;视图更新啦～&apos;); &#125;&#125;let has = &#123;&#125;;let queue = [];let waiting = false;function queueWatcher(watcher) &#123; const id = watcher.id; if (has[id] == null) &#123; has[id] = true; queue.push(watcher); if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue); &#125; &#125;&#125; 我们使用一个叫做 has 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 Watcher 对象 （这样比每次都去遍历 queue 效率上会高很多）。 如果目前队列 queue 中还没有这个 Watcher 对象，则该对象会被 push 进队列 queue 中去。 waiting 是一个标记位，标记是否已经向 nextTick 传递了 flushSchedulerQueue 方法，在下一个 tick 的时候执行 flushSchedulerQueue 方法来 flush 队列 queue，执行它里面的所有 Watcher 对象的 run 方法。 123456789101112function flushSchedulerQueue () &#123; let watcher, id; for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; id = watcher.id; has[id] = null; watcher.run(); &#125; waiting = false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.从浏览器发起请求到页面能正常浏览都有哪些阶段预处理——&gt;DNS解析——&gt;建立连接——&gt;发起请求——&gt;等待响应——&gt;接受数据——&gt;处理元素——&gt;布局渲染 1.应用层DNS域名解析 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表，没有的话再向浏览器默认的DNS服务器发送查询请求并且同时缓存，请求上级DNS服务器，直至找到或到根节点） 浏览器将端口号从URL中解析出来 2.浏览器与网站建立TCP连接​ 浏览器利用ip直接网站主机通信，浏览器发出TCP连接请求，主机返回TCP应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认，浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP连接建立完成。 3.浏览器发起请求​ 浏览器向主机发起一个HTTP-GET方法报文请求，请求中包含访问的URL，还有User-Agent用户浏览器操作系统信息，编码等，值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件，Cookies如果是首次访问，会提示服务器简历用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 4.服务器接收数据并响应请求​ 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。 ​ 服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后在响应报文中Location项找到重定向地址，浏览器重新访问。 ​ 根据请求报文头Content-type返回资源。 5.页面渲染 HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 具体计算每个 DOM 元素最终在屏幕上显示的大小和位置,web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。 Painting 根据计算好的信息绘制整个页面. 包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。 Composite 渲染层合并 对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。 层(GraphicsLayer)是作为纹理(texture)上传给 GPU 的，现在经常能看到说 GPU 硬件加速，就和所谓的层的概念密切相关。 脚本处理： 浏览器解析文档，当遇到script标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 defer或者async。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。 呈现树（Render Tree）Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。呈现器是和 DOM 元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。 布局Layout 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 2.前端优化目的从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ; 第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。 页面级别的优化：1.减少Http请求 最基本有效的方式​ 一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。 时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 另外，由于浏览器进行并发请求的请求数是有上限的 ，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象。 减少 HTTP请求数的主要途径包括： ​ 1.保持页面简洁、减少资源的使用时最直接的 ​ 2.合理设置 HTTP缓存 ​ 3.资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个 ​ CSS Sprites:合并 CSS图片，减少请求数 ​ 4.懒加载 Lazy Load Images：能在某些条件下或者页面刚加载时减少 HTTP请求数 2.将外部脚本置底（将脚本内容在页面信息内容加载后再加载）​ 浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。 ​ 将 CSS放在 HEAD中 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟 3.Lazy Load Javascript​ 框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。 目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。最初只加载核心模块，其他模块可以等到需要使用的时候才加载。 结合vue2中组件懒加载 代码级优化：1.JavaScript DOM​ 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。 2.避免回流和重绘 reflow repaint：频繁触发重绘和回流会导致UI频繁渲染​ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。当页面布局和几何属性改变时就需要回流 ​ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 ​ 回流必将引起重绘，而重绘不一定会引起回流。 触发页面重布局的属性： 盒子模型相关属性会触发重布局 ​ 定位属性及浮动也会触发重布局 ​ 改变节点内部文字结构也会触发重布局 优化： 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择 对于动画新建图层 启用 GPU 硬件加速 将频繁重绘和回流的Dom元素单独作为一个独立图层，这个Dom元素的重绘和回流的影响只会在这个图层上 3.性能优化的具体方法（way）一）内容层面1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名） 2、避免重定向（/还是需要的） 3、切分到多个域名 4、杜绝404 二）网络传输阶段1、减少传输过程中实体的大小 ​ 1）缓存 ​ 2）cookie优化 ​ 3）文件压缩（Accept-Encoding：g-zip） 2、减少请求的次数 ​ 1）文件适当的合并 ​ 2）雪碧图 3、异步加载（并发,requirejs） 4、预加载、延后加载、按需加载 三）渲染阶段1、js放底部，css放顶部 2、减少重绘和回流 ​ 3、合理使用Viewport 等meta头部 ​ 4、减少dom节点 ​ 5、BigPipe 四）脚本执行阶段1、缓存节点，尽量减少节点的查找 2、减少节点的操作（innerHTML） 3、避免无谓的循环，break、continue、return的适当使用 4、事件委托 4.高性能滚动优化及渲染优化网页生成的时候，至少会渲染（Layout+Paint）一次。用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）。其中，用户 scroll 和 resize 行为（即是滑动页面和改变窗口大小）会导致页面不断的重新渲染。 当滚动页面时，浏览器可能会需要绘制层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。 scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流。 防抖（Debouncing）防抖即是是在一定时间内，只在最后一次被触发时，执行处理函数。 12345678910111213141516// 简单的防抖动函数function debounce(func, wait, immediate) &#123; var timeout; // 定时器变量 return function() &#123;//闭包避免timeout变为全局变量 clearTimeout(timeout); // 每次触发 scroll handler 时先清除定时器 timeout = setTimeout(func, wait); // 指定 xx ms 后触发真正想进行的操作 handler &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction realFunc()&#123; console.log(&quot;Success&quot;);&#125;// 采用了防抖动window.addEventListener(&apos;scroll&apos;,debounce(realFunc,500));// 没采用防抖动window.addEventListener(&apos;scroll&apos;,realFunc);//scroll只要改变立即操作handler 封装防抖 123456789101112131415161718// 防抖动函数function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // 滚动中的真正的操作&#125;, 250);window.addEventListener(&apos;resize&apos;, myEfficientFn);// 绑定监听 节流（Throttling）防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 避免处理函数被频繁的触发，让函数每隔一段时间执行一次，当在执行周期内被触发时，不允许被执行。 当触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。并且节流函数多了一个 mustRun 属性，代表 mustRun 毫秒内，必然会触发一次 handler ，同样是利用定时器。 123456789101112131415161718192021// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout,startTime = new Date(); return function() &#123; var context = this,args = arguments,curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args);//触发handler startTime = curTime; &#125;else&#123;// 没达到触发间隔，重新设定定时器 timeout = setTimeout(func, wait); &#125; &#125;;&#125;;function realFunc()&#123;// 实际想绑定在 scroll 事件上的 handler console.log(&quot;Success&quot;); &#125;// 采用了节流函数window.addEventListener(&apos;scroll&apos;,throttle(realFunc,500,1000));//如果在一段时间内 scroll 触发的间隔一直小于500ms ，保证 handler 在 1000ms 内至少触发一次]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 基本元字符 . ： 匹配除了换行符之外的任何单个字符 \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\*/ 将 ‘‘ 的特殊性移除，从而可以匹配像 `”a“` 这样的字符串。 | ： 逻辑或操作符 [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身 [^]：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \$ ： 匹配表达式的结束 \b：匹配单词边界 \B：匹配非单词边界 (?=p)：匹配 p 前面的位置 (?!p)：匹配不是 p 前面的位置 特殊元字符 \d：[0-9]，表示一位数字，记忆方式 digit \D：[^0-9]，表示一位非数字 \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character \S：[^\t\v\n\r\f]，表示非空白符 \w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word \W：[^0-9a-zA-Z]，表示非单词字符 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 match接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 12345678910var str = &apos;For more information, see Chapter 3.4.5.1&apos;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;]// &apos;see Chapter 3.4.5.1&apos; 是整个匹配。// &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。// &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。// &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。// &apos;input&apos; 属性是被解析的原始字符串。复制代码 12345var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replace接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);// newString abc - 12345 - #$*% split 接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test：接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec：同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input 同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。 有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的”hello”这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪: 默认贪婪 123var regex = /\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\d\D\s\S\w\W)都可以等价成这种。比如 123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 匹配保留2位小数的数字/^([1-9]\d*|0)(\.\d{1,2})?$/ 电话号码/(\+86)?1\d{10}/ 身份证/^(\d{15}|\d{17}([xX]|\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o*， *代表位置 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \w([a-zA-Z0-9_]) 和 \W 之间的位置，包括 \w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\b/g, &#39;#&#39;) 结果是 #hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 ‘’，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\Be\Bl\Bl\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\B\B\Be\Bl\Bl\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子：千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 ‘,’ 就好了，写成正则就是123123213.replace(/(?=(\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 ‘,’ 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\d(?=(\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 ‘,’ 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组：主要是括号的使用分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\d{4}-\d{2}-\d{2}/，这个正则还可以改成分组形式的/(\d{4})-(\d{2})-(\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以 1234var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 捕获组编号：按照普通捕获组中“(”出现的先后顺序，从左到右，从1开始进行编号 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 反向引用的作用通常是用来查找或限定重复，限定指定标识配对出现等等。 对于普通捕获组语法如下：JavaScript不支持命名捕获组,所以对于捕获组的引用就只支持普通捕获组的反向引用和$number方式的引用. 普通捕获组反向引用：\k&lt;number&gt;，通常简写为\number。number是十进制的数字，即捕获组的编号。 1234//替换掉html标签中的属性 var data = &quot;&lt;table id=\&quot;test\&quot;&gt;&lt;tr class=\&quot;light\&quot;&gt;&lt;td&gt; test &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;var reg = /&lt;([a-z]+)[^&gt;]*&gt;/ig;console.log(data.replace(reg, &quot;&lt;$1&gt;&quot;)); //replace中使用 之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种 1232017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\d{4})[-/.](\d{2})[-/.](\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\d{4})([-/.])(\d{2})\2(\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\d)(\d(\d)))\1\2\3\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\1就匹配\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 ‘abbbc’ 和这么一个正则 /ab{1,3}bbc//ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法” 贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;) 前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。操作符： 转义符 \ 括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f, g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是]]></content>
  </entry>
</search>
