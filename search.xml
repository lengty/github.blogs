<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[乱七八糟面试整理]]></title>
    <url>%2F2018%2F12%2F20%2F%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.基本数据类型：String Number Boolean Null空值 Undefined未定义 ES6新增symbol 引用数据类型：多个不同数据类型值构成的对象object。 基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。 var a = 10; var b = a; b = 20; console.log(a); // 10值 b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 引用类型数据：也就是对象类型，比如：Object 、Array 、Function 、Data等。 javascript的引用数据类型是保存在堆内存中的对象。 引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。 var obj1 = new Object(); var obj2 = obj1; obj2.name = “我有名字了”; console.log(obj1.name); // 我有名字了 obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 总结区别 a 声明变量时不同的内存分配： js中变量都是保存在栈内存中 1）原始值：基本数据类型的值直接保存在栈内存中，值与值之间相互独立。 这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。 2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。变量中只是保存了对象的引用地址，对象属性的值存储在堆内存。 这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。 当比较两个基本数据类型的值是就是比较值,当比较两个引用数据类型时，比较的是对象的内存地址。（每次new都在堆内存开辟一个地址空间） b 不同的内存分配机制也带来了不同的访问机制 1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。 2）而原始类型的值则是可以直接访问到的。 c 复制变量时的不同 1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。 d 参数传递的不同（把实参复制给形参的过程） 首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。 2.事件冒泡，事件委托 ​ 事件流是从页面接收事件的顺序。JS事件流原理图如下：（JS支持了冒泡流和捕获流，但是目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)） 事件传播三个阶段:一个完整的JS事件流是从window开始，最后回到window的一个过程 (1~5)捕获过程：从最外层祖先元素向目标元素进行事件的捕获，默认此时不触发事件 (5~6)目标过程：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 (6~10)冒泡过程：从目标元素向祖先元素传递，依次触发祖先元素上的事件 IE8及以下浏览器没有捕获阶段。 事件冒泡：IE在处理上述事件时候，是由事件开始最具体的元素接收，然后逐级向上传播到根节点。当后代元素上的事件被触发时，其祖先元素上的相同事件也会被触发。 事件捕获：接收事件的顺序为根节点到具体的节点。 · 捕获阶段：首先window会获捕获到事件，之后document、documentElement、body会捕获到，再之后就是在body中DOM元素一层一层的捕获到事件，有wrapDiv、innerP。 · 目标阶段：真正点击的元素的事件发生了两次。 [在目标元素上就不会遵守先发生捕获后发生冒泡这一规则，而是先绑定的事件先发生。] · 冒泡阶段：会和捕获阶段相反的步骤将事件一步一步的冒泡到window e.target和e.currentTarget target和currentTarget都是event上面的属性，target是真正发生事件的DOM元素-触发事件的真正对象，而currentTarget是当前事件发生在哪个DOM元素上（每一层）。 DOM事件流： “DOM2级事件”规定的事件流依次三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。事件捕获的意义在于，能够在目标获得点击事件之前截获事件，并对其作出相应的处理。 事件处理程序: DOM0级事件处理程序：这种指定事件处理程序具有简单，跨浏览器的优点，其事件处理程序会在事件流的冒泡阶段被触发。注意，此种方式无法为同一个元素对同一事件指定多个事件处理程序，如果绑定多次，就会以最后一次为准。event.onclick=fun DOM2级事件处理程序：addEventListener()和removeEventListener()。它们接受三个参数：处理的事件名称(事件字符串，无on)，事件处理程序(当事件触发时被调用)，指定是在事件冒泡还是事件捕获阶段处理的布尔值，true则为在事件捕获阶段处理，false为在事件冒泡阶段处理。需要注意的是，通过addEventListener()指定的事件处理程序智能通过removeEventListener()移除；同时，如果在addEventListener()中的第二个参数是一个匿名函数，则无法通过removeEventListener()移除，也没有办法移除。不支持IE8及以下。 IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()，这两个方法直接收两个参数，第一个为事件名称（注意事件名称都有on前缀，例如click事件则为onclick），第二个参数为事件处理程序函数。 不同的是后绑定先执行 缺点：IE仅支持事件捕获的冒泡阶段；attachEvent()事件监听函数内的this关键字指向了window对象，而不是当前元素（IE的一个巨大缺点），而addEventListener()中的this是绑定事件的对象；事件对象仅存在与window.event参数中； 1234if(eventobj.addEventListener) //大部分浏览器兼容 eventobj. addEventListener(eventStr,callback,false)else //IE8及以下 将this绑定在事件对象 eventobj.attachEvent(‘on’+eventStr, function()&#123; callback.call(eventobj)&#125;) 解除事件： 123element.removeEventListener(&apos;click&apos;, function(e)&#123;&#125;, false);IE: element.detachEvent(&apos;onclick&apos;, function()&#123;&#125;); 阻止事件传播: 在支持addEventListener()的浏览器中，可以调用事件对象的stopPropagation()方法以阻止事件在传播过程的继续传播。如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation()之后任何其他对象上的事件处理程序将不会被调用。不仅可以阻止事件在冒泡阶段的传播，还能阻止事件在捕获阶段的传播。 IE9之前的IE不支持stopPropagation()方法，而是设置事件对象cancelBubble属性为true来实现阻止事件进一步传播。 阻止事件的默认行为 e.preventDefault()可以阻止事件的默认行为发生。默认行为是指：点击a标签就转跳到其他页面、拖拽一个图片到浏览器会自动打开、点击表单的提交按钮会提交表单等等，因为有的时候我们并不希望发生这些事情，所以需要阻止默认行为。 IE9之前的IE中，可以通过设置事件对象的returnValue属性为false达到同样的效果。return false 123456789function cancelHandler(event)&#123; var event = event||window.event; //兼容IE//取消事件相关的默认行为if(event. preventDefault) event. preventDefault(); //标准技术if(event.returnValue) event. returnValue=false; //兼容IE9之前的IE return false；//用于处理使用对象属性注册的处理程序event.onclick&#125; 事件委托： JavaScript影响网页应用性能有很多方面，如：每个函数都是对象，都会占用内存；内存中的对象越多，性能越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数越多，就会造成越长的页面交互就绪时间。所以多个事件处理程序过多就会降低事件的性能，解决这种问题的方案就是事件委托。 事件委托利用事件冒泡，只指定一个事件处理程序，就可以管理某一类的所有事件(绑定给元素的共同祖先元素，谁触发都会导致祖先元素上事件触发)。 事件委托还有一个好处就是添加进来的元素也能绑定事件： 但是，不建议对mouseover和mouseout使用事件代理，因为当鼠标从一个元素移到其子节点时，或者当鼠标移除该元素时，都会触发mouseout事件。 事件对象： ​ 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数function（event）{}，在事件对象中封装了当前事件相关的一切信息，比如鼠标坐标、哪个键盘按键被按下、鼠标滚轮滚动的方向。 在IE8中响应函数被触发时，浏览器不会传递事件对象，在IE8及以下浏览器中将事件对象作为window对象的属性保存。window.event。 兼容性：if(!event) event=window.event;或更常见 event=event||window.event; 重排和重绘 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。 什么情况会触发重排和重绘？ 添加、删除、更新 DOM 节点 通过 display: none 隐藏一个DOM节点-触发重排和重绘 通过 visibility: hidden 隐藏一个DOM节点-只触发重绘，因为没有几何变化 移动或者给页面中的 DOM 节点添加动画 添加一个样式表，调整样式属性 用户行为，例如调整窗口大小，改变字号，或者滚动。 1.prototype属性 在典型的面向对象的语言中，如java，都存在类（class）的概念，类就是对象的模板，对象就是类的实例。但是在Javascript语言体系中，是不存在类（Class）的概念的，javascript中不是基于‘类的’，而是通过构造函数（constructor）和原型链（prototype chains）实现的。但是在ES6中提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让原型对象的写法更加清晰、更像面向对象编程的语法而已。 实例对象.proto指向原型对象，实例对象无prototype 构造函数.prototype指向原型对象 原型对象.constructor指向构造函数Foo.prototype.constructor = Foo 总结：函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然如此，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.proto = null表示原型链的最顶端，如此变形成了JavaScript的原型链继承，同时也解释了为什么所有的JavaScript对象都具有Object的基本方法。 构造函数： ​ 所谓构造函数，就是提供了一个生成对象的模板并描述对象的基本结构的函数，可以生成多个对象，每个对象都有相同的结构。总的来说，构造函数就是生成对象的模板，对象就是构造函数的实例。所有的实例对象都可以继承构造函数中的属性和方法。但是，同一个对象实例之间，无法共享属性。 Prototype属性的作用 为了解决构造函数的对象实例之间无法共享属性的缺点，js提供了prototype属性。js中每个数据类型都是对象（除了null和undefined），而每个对象都继承自另外一个对象，后者称为“原型”（prototype）对象，只有null除外，它没有自己的原型对象。 原型对象上的所有属性和方法，都会被对象实例所共享。 通过构造函数生成对象实例时，会将对象实例的原型指向构造函数的prototype属性。每一个构造函数都有一个prototype属性，这个属性就是对象实例的原型对象。 对于构造函数来说，prototype是作为构造函数的属性；对于对象实例来说，prototype是对象实例的原型对象。所以prototype即是属性，又是对象。 原型对象的属性不是对象实例的属性。对象实例的属性是继承自构造函数定义的属性，因为构造函数内部有一个this关键字来指向将要生成的对象实例。对象实例的属性，其实就是构造函数内部定义的属性。只要修改原型对象上的属性和方法，变动就会立刻体现在所有对象实例上。 当某个对象实例没有该属性和方法时，就会到原型对象上去查找。如果实例对象自身有某个属性或方法，就不会去原型对象上查找。 总结一下： a：原型对象的作用，就是定义所有对象实例所共享的属性和方法。 b：prototype，对于构造函数来说，它是一个属性；对于对象实例来说，它是一个原型对象。 指向构造函数的原型对象可以通过proto来访问属性 1var mc=new Myclass(); mc.proto==Myclass.prototype//true 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有也会返回true。 使用对象的hasOwnProperty()来检查自身中是否含有该属性mc.hasOwnProperty(“name”) 只有当对象自身中含有属性时才会返回true。 原型链 prototype chains 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型对象本身对于对象实例来说也是对象，它也有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。所有一切的对象的原型顶端，都是Object.prototype，即Object构造函数的prototype属性指向的那个对象。 当然，Object.prototype对象也有自己的原型对象，那就是没有任何属性和方法的null对象，而null对象没有自己的原型。 1 console.log(Object.getPrototypeOf(Object.prototype)); //null 2 console.log(Person.prototype.isPrototypeOf(boy)) //true 原型链（prototype chain）的特点有： a：读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。 b：如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overiding）。 c：一级级向上在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 constructor属性 Foo.prototype.constructor = Foo prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 1234function A()&#123;&#125;;console.log(A.prototype.constructor===A) //trueconsole.log(A.hasOwnProperty(&apos;prototype&apos;)); //trueconsole.log(A.prototype.hasOwnProperty(&apos;constructor&apos;)); //true 由于constructor是定义在原型（prototype）对象上面，意味着可以被所有实例对象继承。 123var a=new A(); console.log(a.constructor); //A()console.log(a.constructor===A.prototype.constructor);//true 上面代码中，a是构造函数A的实例对象，但是a自身没有contructor属性，该属性其实是读取原型链上面的A.prototype.constructor属性。 constructor属性的作用 a：分辨原型对象到底属于哪个构造函数 function A(){}; var a=new A(); console.log(a.constructor===A) //true 会沿着原型链 b：从实例新建另一个实例 function A() {}; var a = new A(); var b = new a.constructor(); console.log(b instanceof A); //true 上面代码中，a是构造函数A的实例对象，可以从a.constructor间接调用构造函数。 c：调用自身的构造函数成为可能 12345function Father() &#123;&#125; function Son() &#123; Son.height.constructor.call(this);&#125; Son.height = new Father(); 上面代码中，Father和Son都是构造函数，在Son内部的this上调用Father，就会形成Son继承Father的效果。 e：由于constructor属性是一种原型对象和构造函数的关系，所以在修改原型对象的时候，一定要注意constructor的指向问题。 解决方法有两种，要么将constructor属性指向原来的构造函数，要么只在原型对象上添加属性和方法，避免instanceof失真。 instanceof运算符 通过构造函数创建的对象就是该构造函数的实例 instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。 只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 typeof 操作符 一样用处不大。 function A() {}; var a = new A(); console.log(a instanceof A); //true 因为instanceof对整个原型链上的对象都有效，所以同一个实例对象，可能会对多个构造函数都返回true。 console.log(a instanceof A); //true console.log(a instanceof Object); //true 注意，instanceof对象只能用于复杂数据类型（数组，对象等），不能用于简单数据类型（布尔值，数字，字符串等）。 var b = true; var c = ‘string’; console.log(b instanceof Boolean); //false console.log(c instanceof String); //false 此外，null和undefined都不是对象，所以instanceof 总是返回false。 console.log(null instanceof Object); //false console.log(undefined instanceof Object); //false 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。 123456function Keith(name,height) &#123; if (! this instanceof Keith) &#123; return new Keith(name,height); &#125; this.name = name; this.height = height;&#125; 上面代码中，使用了instanceof运算符来判断函数体内的this关键字是否指向构造函数Keith的实例，如果不是，就表明忘记加new命令，此时构造函数会返回一个对象实例，避免出现意想不到的结果。 typeof和instanceof： typeof方法返回一个字符串，来表示数据的类型 用typeof来判断数据类型其实并不准确。数组、正则、日期、对象的typeof返回值都是object。 所以在typeof判断类型的基础上，我们还需要利用Object.prototype.toString方法来进一步判断数据类型。toString方法和typeof方法返回值的区别： 为了检测一个对象的类型，强烈推荐使用 Object.prototype.toString 方法，因为这是唯一一个可依赖的方式。所以我们一般通过该方法来进行数据类型的验证。 除非为了检测一个变量是否已经定义，我们应尽量避免使用 typeof 操作符。 this指向： 当以函数的形式调用时，直接调用函数时，this 指向全局对象 12345678910111213141516foo(); //this是全局对象，即使在方法内部调用也是指向全局对象foo.method = function() &#123; let that = this; console.log(this); //Foo function test() &#123; console.log(this);//window console.log(that);//Foo &#125; test();//方法内部直接调用某一函数也是指向全局对象 &#125;;foo.methodTest = function() &#123; console.log(this);&#125;;foo.methodTest(); //foo对象let t = foo.methodTest;t();//this指向全局对象 当以方法的形式调用时，谁调用方法this就是谁 当以构造函数的形式调用时，this就是新创建的对象 使用call.apply调用时，this是指定的对象（第一个参数） 事件响应函数中，响应函数绑定给谁this就是谁 call、apply、bind方法的共同点和区别： apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 （1）call call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 说明： call 方法可以用一个对象来代替另一个对象调用一个方法。 call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 thisObj的取值有以下4种情况： （1） 不传，或者传null,undefined， 函数中的this指向window对象 （2） 传递另一个函数的函数名，函数中的this指向这个函数的引用 （3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean （4） 传递一个对象，函数中的this指向这个对象 （2）apply apply([thisObj[,argArray]]) apply和call作用完全一样，只是接受参数的方式不太一样。 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call ；而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 （3）bind bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 闭包：函数可以嵌套定义在其他函数内部，这样它就可以访问它们被定义时所处的作用域中的任何变量。作用域链在函数定义时创建，并一直绑定在函数上。 作用域链：嵌套函数当前对象（包含函数参数和变量）—外层函数对象—全局对象 定义一个函数，实际上保存了一个作用域链 调用这个函数，会创建一个新对象存储局部变量，将这个对象放在作用域链头部 with()函数用于临时扩展作用域链，将obj添加到作用域链头部 函数在它自己的作用域中执行，而不是在调用它的作用域中执行。 1.每次调用JavaScript函数，都会创建一个新的对象，保存局部变量，把这个对象添加至作用域链。 2.每次返回，从作用域链中将绑定对象删除 如果不存在嵌套函数，也没有其他引用指向这个对象，则垃圾回收 如果定义了嵌套函数，并将其作为返回值返回或存储在某处的属性中，这时就会有一个外部引用指向这个嵌套函数。不会被垃圾回收，并且指向的变量绑定对象也不会被垃圾回收。 12345678910111213141516function counter() &#123; var count = 0; return &#123; add: function() &#123; count++; &#125;, get: function() &#123; return count; &#125; &#125;;&#125;let c1 = counter();let c2 = counter();c1.add();console.log(c1.get()); //1console.log(c2.get()); //0 以上代码，每一次调用形成一个新的对象，形成两个闭包add，get。 对象中保存了当前保存变量和参数的对象，同一个对象中共享变量，两次调用形成不同对象间互不干扰。 循环中的闭包 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 0);&#125; //输出10 上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。 当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10。为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。 避免引用错误: 为了正确的获得循环序号，最好使用 匿名包装器（其实就是我们通常说的自执行匿名函数）。 外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。 这里的陷阱就是：函数带()才是执行函数！ 单纯的一句 var f = function() { alert(‘Hi’); }; 是不会弹窗的， f(); 才会执行函数内部的代码。 原理：在同一个函数调用中，形成的10个闭包存储在一个数组中，保存在同一个对象中共享变量。 使用闭包的注意点 1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。不必要的闭包只会徒增内存消耗。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 函数作用域 在ES6之前，JS作用域只有两种：函数作用域和全局作用域 ES6定义了块级作用域，使用let声明的变量不会提升，函数声明会完全提升。使用let声明的变量只能在块级作用域里访问，声明前不可用（暂时性死区） 每次引用一个变量，JavaScript 会向上遍历整个作用域直到找到这个变量为止。 如果到达全局作用域但是这个变量仍未找到，则会抛出 ReferenceError 异常。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 使用var 声明和 function 声明都将会被提升到当前作用域的顶部。 函数声明提前： 函数定义形参相当于在函数作用域中声明了变量 使用函数声明形式创建的函数function fun(){}会在所有代码执行之前被创建 使用函数表达式创建的函数var fun=function(){}不会被声明提前 函数声明先提升，变量后提升，且函数声明会被提升到普通变量之前（变量提升时，只提升了声明，并没有被赋值） 名称解析顺序 JavaScript 中的所有作用域，包括全局作用域，都有一个特别的名称 this 指向当前对象。 函数作用域内也有默认的变量 arguments，其中包含了传递到函数中的参数。 比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找： 1.当前作用域内是否有 var foo 的定义。 2.函数形式参数是否有使用 foo 名称的。 3.函数自身是否叫做 foo。 4.回溯到上一级作用域，然后从 #1 重新开始。 命名空间 只有一个全局作用域导致的常见错误是命名冲突，在JS中可以通过匿名包装器解决。 推荐使用匿名包装器（自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突， 而且有利于程序的模块化。 arguments：在调用函数时，浏览器每次都会传递进两个隐含的参数： 函数的上下文对象this 封装的实参对象arguments：arguments是一个类数组对象（有数组操作但不是数组类型） 调用函数时，所传递的实参都会保存在arguments对象中 它里面有一个callee属性：这个属性对应一个函数就是当前正在指向的函数的对象。 解决setTimeout中函数this是指向全局对象问题 这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向全局对象。 1.将当前对象的this存为一个变量，定时器的函数利用闭包来访问这个变量 123456function obj()&#123; var that = this ; setTimeout(function()&#123; … console.log(that.num)//利用闭包访问that，that是一个指向obj的指针 &#125;,1000)&#125; 2.利用bind()方法 123setTimeout(function()&#123; console.log(this.num);&#125;.bind(this),1000)//利用bind()将this绑定到这个函数上 3.箭头函数 123setTimeout(()=&gt;&#123; console.log(this.num); &#125;,1000)//箭头函数中的this总是指向外层调用者，obj ES6中的箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题。 类型转换：强制和自动的规则 显示类型转换 1.Number(mix)函数，可以将任意类型的参数mix转换为数值类型。其规则为： （1）如果是布尔值，true和false分别被转换为1和0 （2）如果是数字值，返回本身。 （3）如果是null，返回0。 （4）如果是undefined，返回NaN。 （5）如果是字符串，遵循以下规则： ​ 1、如果字符串中只包含数字，则将其转换为十进制（忽略前导0） ​ 2、如果字符串中包含有效的浮点格式，将其转换为浮点数值（忽略前导0） ​ 3、如果是空字符串，将其转换为0 ​ 4、如果字符串中包含非以上格式，则将其转换为NaN 123console.log(Number(&quot;010&quot;)); //10console.log(Number(&quot;0o10&quot;));//8console.log(Number(&quot;0x10&quot;));//16 （6）如果是对象，则调用对象的valueOf()方法，然后依据前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，再次依照前面的规则转换返回的字符串值。 123console.log(new Number(10) === 10)// False, 对象与数字的比较console.log(Number(10) === 10) // True, 数字与数字的比较console.log(new Number(10) + 0 === 10);// True, 由于隐式的类型转换 parseInt(string, radix)函数，将字符串转换为整数类型的数值。它也有一定的规则： （1）忽略字符串前面的空格，直至找到第一个非空字符 （2）如果第一个字符不是数字符号或者负号，返回NaN （3）如果第一个字符是数字，则继续解析直至字符串解析完毕或者遇到一个非数字符号 （4）如果以0x开头，则将其当作十六进制来解析 12345//0x18 = 8*16^0 + 1*16^1 = 24 let n = 0o20;console.log(n);//16console.log(parseInt(&quot;0o20&quot;)); //0console.log(parseInt(&quot;020&quot;)); //20 （5）如果指定radix参数，则以radix为基数进行解析 parseFloat(string)函数，将字符串转换为浮点数类型的数值。 它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。 12console.log(parseFloat(&quot;000013.002&quot;));//13.002console.log(parseFloat(&quot;000013.000&quot;));//13 toString(radix)方法。除undefined和null之外的所有类型的值都具有toString()方法，其作用是返回对象的字符串表示 5、String(mix)函数，将任何类型的值转换为字符串，其规则为： （1）如果有toString()方法，则调用该方法（不传递radix参数）并返回结果 （2）如果是null，返回’’null” （3）如果是undefined，返回”undefined” 6、Boolean(mix)函数，将任何类型的值转换为布尔值。 以下值会被转换为false：false、””、0、NaN、null、undefined，其余任何值都会被转换为true 隐式类型转换 在某些情况下，即使我们不提供显示转换，Javascript也会进行自动类型转换，主要情况有： 1、 用于检测是否为非数值的函数：isNaN(mix) isNaN()函数，经测试发现，该函数会尝试将参数值用Number()进行转换，如果结果为“非数值”则返回true，否则返回false。 2、递增递减操作符（包括前置和后置）、一元正负符号操作符 ​ 这些操作符适用于任何数据类型的值，针对不同类型的值，该操作符遵循以下规则（经过对比发现，其规则与Number()规则基本相同）： ​ （1）如果是包含有效数字字符的字符串，先将其转换为数字值（转换规则同Number()），在执行加减1的操作，字符串变量变为数值变量。 ​ （2）如果是不包含有效数字字符的字符串，将变量的值设置为NaN，字符串变量变成数值变量。 ​ （3）如果是布尔值false，先将其转换为0再执行加减1的操作，布尔值变量编程数值变量。 ​ （4）如果是布尔值true，先将其转换为1再执行加减1的操作，布尔值变量变成数值变量。 ​ （5）如果是浮点数值，执行加减1的操作。 （6）如果是对象，先调用对象的valueOf()方法，然后对该返回值应用前面的规则。如果结果是NaN，则调用toString()方法后再应用前面的规则。对象变量变成数值变量。 123456789let b = true;console.log(++b); //2console.log(++b); //3let str = &quot;aa123&quot;;console.log(++str);//Nanstr = &apos;00123&apos;console.log(++str);//124str = &quot;02dd&quot;;console.log(++str);//NaN 3、加法运算操作符 如果两个操作值都是数值，其规则为： (1)如果一个操作数为NaN，则结果为NaN (2)如果是Infinity+Infinity，结果是Infinity (3)如果是-Infinity+(-Infinity)，结果是-Infinity (4)如果是Infinity+(-Infinity)，结果是NaN (5)如果是+0+(+0)，结果为+0 (6)如果是(-0)+(-0)，结果为-0 (7)如果是(+0)+(-0)，结果为+0 1+&apos;10&apos; === 10; // true 使用一元的加号操作符，可以把字符串转换为数字。 如果有一个操作值为字符串，则： 如果两个操作值都是字符串，则将它们拼接起来 如果只有一个操作值为字符串，则将另外操作值转换为字符串，然后拼接起来 ​ 如果一个操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值，然后再应用前面的字符串规则。对于undefined和null，分别调用String()显式转换为字符串。 可以看出，加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来。 4、 乘除、减号运算符、取模运算符 这些操作符针对的是运算，所以他们具有共同性：如果操作值之一不是数值，则被隐式调用Number()函数进行转换。 5、 相等操作符（==） 相等操作符会对操作值进行隐式转换后进行比较： （1）如果一个操作值为布尔值，则在比较之前先将其转换为数值 （2）如果一个操作值为字符串，另一个操作值为数值(包括优先转换过来的数值)，则通过Number()函数将字符串转换为数值 （3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较 （4）null与undefined是相等的 （5）如果一个操作值为NaN，则相等比较返回false （6）如果两个操作值都是对象，则比较它们是不是指向同一个对象 6、 关系操作符（&lt;, &gt;, &lt;=, &gt;=） 关系操作符的操作值也可以是任意类型的，所以使用非数值类型参与比较时也需要系统进行隐式类型转换： （1）如果两个操作值都是数值，则进行数值比较 （2）如果两个操作值都是字符串，则比较字符串对应的字符编码值 （3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较 （4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较 （5）如果一个操作值是布尔值，则将其转换为数值，再进行比较 注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。 7、逻辑操作符（!、&amp;&amp;、||） 逻辑非（！）操作符首先通过Boolean()函数将它的操作值转换为布尔值，然后求反。 逻辑与（&amp;&amp;）操作符，如果一个操作值不是布尔值时，遵循以下规则进行转换： （1）如果第一个操作数经Boolean()转换后为true，则返回第二个操作值，否则返回第一个值（不是Boolean()转换后的值） （2）如果有一个操作值为null，返回null （3）如果有一个操作值为NaN，返回NaN （4）如果有一个操作值为undefined，返回undefined 逻辑或（||）操作符，如果一个操作值不是布尔值，遵循以下规则： （1）如果第一个操作值经Boolean()转换后为false，则返回第二个操作值，否则返回第一个操作值（不是Boolean()转换后的值） （2）对于undefined、null和NaN的处理规则与逻辑与（&amp;&amp;）相同 实现一个类 构造函数 new一个实例 new的过程 var a = new A(‘testa’) 1、创建一个空对象。var obj = {}; 2、设置新对象的__proto__属性指向构造函数的prototype对象；obj.__proto__ = A.prototype; 3、将构造函数的作用域赋给新对象，this就指向了新对象, 使用新对象调用函数 A.call(obj); //{}.构造函数(); 4、执行构造函数中的代码（给这个新对象添加方法和属性） 5、返回这个对象（this） 如果构造函数中返回的是一个对象，数组，那么就会覆盖返回原来的this对象，如果不是，即使是undefined，null和 空 都是返回this对象。 6、将初始化完毕的新对象地址，保存到等号左边的变量中 注意： 1、用new调用的函数，得到的永远是一个对象，不管函数有没有返回值 2、使用new调用函数，这个函数就是一个用来创建对象的函数（构造函数） 123let f = new Foo();console.log(typeof f); //objectconsole.log(typeof Foo);//function 原型继承：子类型基于父类型，子类型拥有父类型所有的属性和方法（从父类型继承得到） 使用new关键字和构造函数的prototype属性都是定义类型的特定方式。 1.实现JS的继承： ​ // 设置原型：将子对象构造函数的prototype属性指向父对象的一个实例 ​ Employee.prototype = new Person() ​ // 设置原型的构造器 Employee.prototype.constructor=Employee prototype.constructor仅可以用于识别对象是由哪个构造函数初始化的,用于constructor类型判断 2.为了避免上一个方法需要重复创建原型对象实例的问题，可以直接将子对象构造函数的prototype指向父对象构造函数的prototype，这样，所有Parent.prototype中的属性和方法也能被重用，同时不需要重复创建原型对象实例： ​ Child.prototype = Parent.prototype ​ Child.prototype.constructor = Child 在 JavaScript 中，对象是作为引用类型存在的，这种方法实际上是将Child.prototype和Parent.prototype中保存的指针指向了同一个对象，因此，当我们想要在子对象原型中扩展一些属性以便之后继续继承的话，父对象的原型也会被改写，因为这里的原型对象实例始终只有一个，这也是这种继承方式的缺点。 3.直接将父对象设置为子对象的原型，ES5 中的 Object.create()方法 多层继承： 12345678910111213141516171819202122232425262728293031323334function Person() &#123;&#125; Person.prototype.name = &quot;person&quot;; Person.prototype.say = function() &#123; //如果对象不存在name属性，则使用原型链的name if (!this.name) &#123; this.name = this.proto.name; &#125; console.log(this.name); &#125;; function Man() &#123;&#125; //设置Man继承Person Man.prototype = new Person(); Man.prototype.constructor = Man; // 继承可以通过设置原型对象上的属性保存父类的方法属性 Man.prototype.superClass = new Person(); Man.prototype.name = &quot;man&quot;; Man.prototype.say = function() &#123; console.log(this.name); &#125;; function Child() &#123;&#125; Child.prototype = new Man(); Child.prototype.superClass = new Man(); Child.prototype.say = function() &#123; console.log(&quot;child&quot;); &#125;; var c = new Child(); c.say(); //child c.superClass.say(); //man c.superClass.superClass.say(); //person c.name = &quot;child&quot;; c.superClass.say.call(c); //child 多重继承：从多个父类型派生出一个子类型 1.使用call、apply绑定this ​ var s1 = function(name) { var s2 = function(sex) { ​ this.name = name; this.sex = sex; ​ this.getName = function() { }; ​ console.log(this.name) var s3 = function(age) { ​ } this.age = age; ​ }; }; ​ var Student = function(name, sex, age, score) { ​ s1.call(this, name); s2.call(this, sex); s3.call(this, age); ​ this.score = score; ​ }; ​ Student.prototype.constructor = Student; ​ var s = new Student(“jack”, “male”, “12”, “100”);//参数过多的话可以使用object参数 这种方式的最大优势就是，在子对象的构造器中，是对子对象的自身属性进行完全的重建，引用类型的变量也会生成一个新值而不是一个引用，所以对子对象的任何操作都不会影响父对象。而这种方法的缺点在于，在子对象的构建过程中没有使用过new操作符，因此子对象不会继承父级原型对象上的任何属性，基类的方法只能定义在类中，这样在每次实例化的时候都会创建该方法，造成多余内存占用 如果单继承中使用可以手动将子对象构造器原型设为父对象的实例：Child.prototype = new Parent()解决问题。 2.传入多个需要拷贝属性的对象，依次进行属性的全拷贝 ​ function multi() { ​ var n = {}, stuff, i = 0, ​ len = arguments.length ​ for (i = 0; i &lt; len; i++) { ​ stuff = arguments[i] ​ for (var key in stuff) { ​ n[i] = stuff[i] ​ } ​ } ​ return n ​ } 根据对象传入的顺序依次进行拷贝，但是如果后传入的对象包含和前面对象相同的属性，后者将会覆盖前者。 style currentStyle getComputedStyle 1、 style：只能取到内联样式设置的值，设置的样式也都是内联样式 //写 .style = “… : … ; … : …” //读 .style.width = “” 返回的是字符串，带px或者是auto，如果没有设定内联样式返回空字符串 2、currentStyle: 只兼容IE,不兼容火狐和谷歌 读取当前元素正在显示的样式 ​ ele.currentStyle[“attr”] 或者ele.currentStyle.attr; 3、getComputedStyle: 兼容火狐谷歌,不兼容IE ​ window.getComputedStyle(ele,null)[attr] 或者 window.getComputedStyle(ele,null).attr 解决兼容 1234567function getStyle(obj, name) &#123; if (window.getComputedStyle) &#123; return getComputedStyle(obj, null)[name]; &#125; else &#123; return obj.currentStyle[name]; &#125;&#125; 本身的宽高,不包括border 本身的宽高,包括border • clientWidth • offsetWidth • clientHeight • offsetHeight 距离左侧和上部的距离,相对于窗口 获取左边框宽度和上边框宽度 • offsetLeft • clientLeft • offsetTop • clientTop 获取可以滚动的宽度(不包括border) 如果内容宽高比本身小,该值为本身宽高,否则就是内容的宽高 • scrollWidth • scrollHeight 滚动出去的距离 相对于窗口左上角的点 • scrollLeft • clientX • scrollTop • clientY 相对于屏幕左上角的点(建议移动端使用) 相对于本身左上角的点(非标准属性) • screen •offsetX • screenY • offsetY 相对于整个文档左上角的点(建议移动端使用) • pageX • pageY 获取窗口的宽高 获取正文的宽高(可以滚动的宽高) • document.body.clientWidth • document.body.scrollWidth • document.body.clientHeight • docuemnt.body.scrollHeight • document.body.offsetWidth (border) • docuemnt.body.offsetHeight (border) 获取正文滚出去的宽高 获取屏幕分辨率宽高 • document.body.scrollTop • window.screen.width • document.body.scrollLeft • window.screen.height window.location对象 window.location===document.location。location的属性表。 以”http://www.google.com:8080/loanOrder/detail?orderId=1236#type&quot;为例 属性名 例子 说明 hash “#type” 设置或返回URL中的#后面的hash值，如果没有则为”” host “www.google.com:8080&quot; 设置或返回URL中的主机名称和端口号 hostName “www.google.com&quot; 设置或返回URL中的主机名称 href “http://www.google.com:8080 /loanOrder /detail?orderId=1236 #type” 设置或返回完整的URL pathname “/loanOrder/detail” 设置或返回当前 URL 的路径部分 port “8080” 设置或返回URL中的端口号，如果URL中没有端口号，则为”” protocol “http:” 设置或返回当前 URL 的协议，通常是http:或https: search “?orderId=1236” 返回URL的查询字符串。这个字符串以”?”开头 location的8个属性都是可读写的，但是只有href与hash的写才有意义。 例如改变location.href会重新定位到一个URL，而修改location.hash会跳到当前页面中的锚点(或者等)名字的标记(如果有)，而且页面不会被重新加载。 1.查询字符串参数 function getArgsQuery() { ​ //取得查询字符串并去掉”?” ​ var searchStr=window.location.search.length&gt;0?window.location.search.substring(1):””; ​ //将每一项集成到数组中 ​ var searchStrArray=searchStr.length&gt;0?searchStr.split(“&amp;”):[]; ​ var args={}; ​ searchStrArray.forEach(function (item) { ​ //属性 ​ var name=decodeURIComponent(item.split(“=”)[0]); ​ //值 ​ var value=decodeURIComponent(item.split(“=”)[1]); ​ args[name]=value; ​ }); ​ return args; } 2.改变浏览器的位置 1) window.location.reload() //重新加载页面 在调用reload()不传任何参数时，页面自上次请求以来并没有改变过，页面就会从游览器缓存中加载，如果传入参数true时，页面会强制从服务器重新加载。 例： window.location.reload() //重新加载（有可能从缓存中加载） ​ window.location.reload(true) //重新加载(从服务器重新加载) 2) window.location.assign(url); //加载新的文档 效果一样的还有 - window.location.href=url; - window.location=url; 3) window.location.replace(url); //用新文档替换当前文档 同样是加载新文档，区别就是window.location.assign(url)是可以从新文档再回到当前文档，但是window.location.replace(url)就不行了。 url中#(hash)的含义 1.“#”代表网页中的一个位置。其右面的字符，就是该位置的标识符 比如：http://www.example.com/index.html#print 就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。（单页应用） 为网页位置指定标识符，有两个方法。一是使用锚点，比如&lt;a name=&quot;print&quot;&gt;&lt;/a&gt; 二是使用id属性，比如&lt;div id=&quot;print&quot; &gt;。 2.HTTP请求不包括’#’ ‘#’是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括#。 比如，访问下面的网址， http://www.example.com/index.html#print 浏览器实际发出的请求是这样的： GET /index.html HTTP/1.1 Host: www.example.com 可以看到，只是请求index.html，根本没有”#print”的部分。 #后的字符不会被发送到服务器端 在第一个#后面出现的任何字符，都会被浏览器解读为位置标识符。这意味着，这些字符都不会被发送到服务器端。 比如，下面URL的原意是指定一个颜色值：http://www.example.com/?color=#fff 但是，浏览器实际发出的请求是：GET /?color= HTTP/1.1 Host: www.example.com 可以看到，”#fff”被省略了。只有将#转码为%23，浏览器才会将其作为实义字符处理。也就是说，上面的网址应该被写成：http://example.com/?color=%23fff 4.改变#不触发网页重载 单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。 比如，从http://www.example.com/index.html#location1 改成http://www.example.com/index.html#location2 浏览器不会重新向服务器请求index.html。 5.改变#会改变浏览器的访问历史 每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置。 这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。 值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。 6.window.location.hash读取#值 window.location.hash这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录。 hashchange事件：监听 url hash 的改变 这是一个HTML 5新增的事件，当#值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0+支持该事件。 window.addEventListener(‘hashchange’, function(e) { //事件处理 }) 对于不支持onhashchange的浏览器，可以用setInterval监控location.hash的变化。 数组去重 双循环 sort排序后去重 单循环 indexof 对象属性去重 set和解构赋值 return […new Set(arr)] Array.from和set Array.from(new Set(arr)) 0.1+0.2 !== 0.3 0.3 / 0.1===2.9999999999999996以及0.7 * 180==125.99999999998 Number类型遵循了IEEE754-2008中的64位浮点数规则定义的小数后的有效位数至多为52位导致计算出现精度丢失问题！不区分整数和浮点数，都是用64位浮点数的形式储存 原因是JS中的Number类型，二进制小数的有效位数只有52位，从0到51位（包括边界） 解决方法： 1.引入类库require math.js big.js 2.原生方法 Number.prototype.toFixed() 在判断浮点数运算结果前对计算结果进行精度缩小，因为在精度缩小的过程总会自动四舍五入 toFixed() 方法使用定点表示法来格式化一个数，会对结果进行四舍五入。语法为： numObj.toFixed(digits) 参数 digits 表示小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。 返回一个数值的字符串表现形式，不使用指数记数法，而是在小数点后有 digits 位数字。该数值在必要时进行四舍五入，另外在必要时会用 0 来填充小数部分，以便小数部分有指定的位数。 如果数值大于 1e+21，该方法会简单调用 Number.prototype.toString()并返回一个指数记数法格式的字符串。 特别注意：toFixed() 返回一个数值的字符串表现形式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F12%2F20%2FES6%2F</url>
    <content type="text"><![CDATA[1.解构赋值用途（1）交换变量的值：let x = 1; let y = 2; [x, y] = [y, x]; （2）从函数返回多个值：函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 1234567891011function example() &#123; // 返回一个数组 return [1, 2, 3];&#125;let [a, b, c] = example();function example() &#123; // 返回一个对象 return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 1234567let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] （4）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value); // first is hello // second is world&#125; 如果只想获取键名，或者只想获取键值，可以写成下面这样。 1234// 获取键名 //普通obj对象for (let [key] of map) &#123;&#125; for (let key in obj) &#123;&#125;// 获取键值for (let [,value] of map) &#123;&#125; （5）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 2.字符串扩展1.传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。这三个方法都支持第二个参数，表示开始搜索的位置。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 2.repeat方法返回一个新字符串，表示将原字符串重复n次。 参数如果是小数，会被取整。如果参数是 0 到-1 之间的小数，则等同于 0。如果repeat的参数是字符串，则会先转换成数字。NaN等同于 0。 12345'x'.repeat(3) // "xxx"'na'.repeat(2.9) // "nana"'na'.repeat(-0.9) // ""'na'.repeat('na') // "" 先转换为数字 NaN 等同于0'na'.repeat('3') // "nanana" 3.字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 4.模板字符串：传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在${}之中。 12345678// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串所有的空格和缩进都会被保留在输出之中`In JavaScript this is not legal.`// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 12345let x = 1; let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;` // "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;` // "3" 模板字符串之中还能调用函数。 1234function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar` // foo Hello World bar 3.数值扩展1.二进制用前缀0b（或0B），八进制0o（或0O），十六进制0x（或0X） 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 1Number('0b111') // 7 Number('0o10') // 8 Number("0x10") //16 2.ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity 注意，如果参数类型不是数值，Number.isFinite一律返回false。 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite("25") // trueNumber.isFinite(25) // trueNumber.isFinite("25") // falseisNaN(NaN) // trueisNaN("NaN") // trueNumber.isNaN(NaN) // trueNumber.isNaN("NaN") // falseNumber.isNaN(1) // false 3.ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 4.Number.isInteger()用来判断一个数值是否为整数。 JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 12Number.isInteger(25) // trueNumber.isInteger(25.0) // true 如果参数不是数值，Number.isInteger始终返回false，不会存在隐式转换。 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 4.箭头函数箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // id: 42 setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。 123456789101112function Timer() &#123; this.s1 = 0; this.s2 = 0; setInterval(() =&gt; this.s1++, 1000); // 箭头函数 setInterval(function () &#123; // 普通函数 this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100); // s1: 3setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); // s2: 0 Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。 箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 12345678910111213141516171819function foo() &#123; // ES5 var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125;function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 123456function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 5.尾递归12345function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 12345function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 123456789101112function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 12345function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。func.arguments：返回调用时函数的参数。func.caller：返回调用当前函数的那个函数。 尾递归优化的实现 尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 12345678function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 123456789function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;//使用蹦床函数执行sum，就不会发生调用栈溢出。trampoline(sum(1, 100000)) // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 123456789101112131415161718192021222324252627function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 6.数组的扩展1.扩展运算符的应用（1）复制数组:数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。ES5 只能用变通方法来复制数组。 1234const a1 = [1, 2];const a2 = a1.concat(); a2[0] = 2;a1 // [1, 2] a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。a2都是a1的克隆。 123const a1 = [1, 2];const a2 = [...a1]; // 写法一const [...a2] = a1; // 写法二 （2）合并数组 扩展运算符提供了数组合并的新写法。 1234567const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组const a = arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ] // ES6 的合并数组const arr = [...arr1, ...arr2, ...arr3];// ['a', 'b', 'c', 'd', 'e'] 123456const a1 = [&#123; foo: 1 &#125;];const a2 = [&#123; bar: 2 &#125;];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，如果是引用类型的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。 （3）与解构赋值结合：扩展运算符可以与解构赋值结合起来，用于生成数组。 1234567891011121314a = list[0], rest = list.slice(1) // ES5[a, ...rest] = list // ES6const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 （4）字符串：扩展运算符还可以将字符串转为真正的数组。 1[...'hello'] // [ "h", "e", "l", "l", "o" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 （5）实现了 Iterator 接口的对象：任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 1234567let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;let arr = [...arrayLike]; // TypeError: Cannot spread non-iterable object. 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 123456let map = new Map([ [1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 123456const go = function*()&#123; //变量go是一个 Generator 函数，执行后返回的是一个遍历器对象 yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 2.Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 12345678910let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组，才能使用数组的方法。只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 123Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;])Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] 字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; 3.Array.of方法用于将一组值，转换为数组。 这个方法的主要目的是弥补数组构造函数Array()的不足。参数个数的不同会导致构造函数Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments); //slice() 方法可从已有的数组中返回选定的元素，不会修改原数组&#125; 4.数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。返回值都是value 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &apos;John&apos;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 5.fill方法使用给定值，填充一个数组。 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7) // [7, 7, 7] 数组中已有的元素，都会被抹去new Array(3).fill(7) // [7, 7, 7] 填充空数组 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2) // [&apos;a&apos;, 7, &apos;c&apos;] [1，2) 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 6.ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 123456789for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index); // 0 1&#125;for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem); // a b&#125;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem); // 0 a&#125; // 1 b 7.Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 123[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN) // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 1if (arr.indexOf(el) !== -1) &#123;&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 1[NaN].indexOf(NaN) // -1 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 8.数组空位：数组的某一个位置没有任何值 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 Array.from方法、扩展运算符（…）会将数组的空位，转为undefined entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 copyWithin()会连空位一起拷贝。 fill()会将空位视为正常的数组位置。 for…of循环也会遍历空位。 7.对象的扩展1.简写 1234567function getPoint() &#123;//属性简写 method() &#123;//方法简写 method:function()&#123;&#125; const x = 1; return &quot;Hello!&quot;; const y = 10; &#125; return &#123;x, y&#125;; //等同于 &#123;x:x , y:y&#125;&#125;getPoint() // &#123;x:1, y:10&#125; 2.ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 3.Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 12345const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果该参数不是对象，则会先转成对象，然后返回。typeof Object.assign(2) // “object” 由于undefined和null无法转成对象，所以如果它们作为第一个参数作为目标对象，就会报错。如果undefined和null不在首参数，就不会报错，会跳过处理。 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 12345const v1 = &apos;abc&apos;;const v2 = true; const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 注意点: Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 1234const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 123const target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;const source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source) // &#123; a: &#123; b: &apos;hello&apos; &#125; &#125; Object.assign可以用来处理数组，但是会把数组视为对象。 1Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 1Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 用途： （1）为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); //将x属性和y属性添加到Point类的对象实例 &#125;&#125; （2）为对象添加方法 1234567Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123;&#125;;SomeClass.prototype.anotherMethod = function () &#123;&#125;; （3）克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; （4）合并多个对象：将多个对象合并到某个对象target。 1const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 1const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 4.属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 （1）for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj)：返回一个数组，包括对象自身(不含继承)所有的可枚举属性（不含 Symbol 属性）的键名 （3）Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 1Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 5.Object.getOwnPropertyDescriptor（obj，指定属性名）方法会返回某个对象属性的描述对象（descriptor）。Object.getOwnPropertyDescriptors（obj）方法，返回指定对象所有自身属性（非继承属性）的描述对象。 1234567function getOwnPropertyDescriptors(obj) &#123; //实现方法 const result = &#123;&#125;; for (let key of Reflect.ownKeys(obj)) &#123; result[key] = Object.getOwnPropertyDescriptor(obj, key); &#125; return result;&#125; 6.Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。Object.setPrototypeOf(object, prototype) 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。Object.getPrototypeOf(obj); 7.this关键字总是指向函数所在的当前对象，ES6 新增了另一个类似的关键字super，指向当前对象的原型对象。 1234567891011121314const proto = &#123; x: &apos;hello&apos;, foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: &apos;world&apos;, foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // &quot;world&quot; super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj 8.Object.keys(obj)方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名。 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值。 Object.create方法的第二个参数（用于对新创建的对象进行初始化 ）添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。 1234567const obj = Object.create(&#123;&#125;, &#123;p: &#123; value: 42, enumerable: true //不设为true默认为false，无法遍历 &#125;&#125;);Object.values(obj) // [42] Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。 Object.entries的基本用途是遍历对象的属性。 12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// &quot;one&quot;: 1// &quot;two&quot;: 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。 123const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125; 自己实现Object.entries方法，非常简单。 1234567891011121314// Generator函数的版本function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;// 非Generator函数的版本function entries(obj) &#123; let arr = []; for (let key of Object.keys(obj)) &#123; arr.push([key, obj[key]]); &#125; return arr;&#125; 9.扩展运算符克隆对象 对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象还拷贝对象原型的属性，可以采用下面的写法。 123456789101112const clone1 = &#123; // 写法一 __proto__: Object.getPrototypeOf(obj), //__proto__属性在非浏览器的环境不一定部署 ...obj&#125;;const clone2 = Object.assign( // 写法二 Object.create(Object.getPrototypeOf(obj)), obj);const clone3 = Object.create( // 写法三 Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 扩展运算符还可以用于合并两个对象 123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 8.Class123456789101112131415161718function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;//ES6改写class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; //定义“类”的方法的时候，前面不需要加上function这个关键字 return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 类的所有方法都定义在类的prototype属性上面，在类的实例上面调用方法，其实就是调用原型上的方法。 1234567class Point &#123; // 等同于 Point.prototype = &#123; constructor() &#123; constructor() &#123;&#125;, // ... toString() &#123;&#125;, &#125; toValue() &#123;&#125;, toString() &#123;&#125; &#125;; toValue() &#123;&#125;&#125; 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。另外，类的内部所有定义的方法，都是不可枚举的。 1234567class Point &#123; constructor()&#123; ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上，constructor），否则都是定义在原型上（即定义在class上）。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 类不存在变量提升（hoist），这一点与 ES5 完全不同。与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 123456789class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod() // TypeError: foo.classMethod is not a function 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125;&#125;Bar.classMethod() // &quot;hello, too&quot; new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 Class 内部调用new.target，返回当前 Class。需要注意的是，子类继承父类时，new.target会返回子类。 9.继承ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 Object.getPrototypeOf(obj)方法可以用来从子类上获取父类,可以使用这个方法判断一个类是否继承了另一个类。 super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 123456789101112class A &#123; constructor() &#123; console.log(new.target.name); //new.target指向当前正在执行的函数 &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B super()内部的this指向的是B。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 12345678910111213class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined p是父类A实例的属性，super.p就引用不到它 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 123456789class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // true// 等同于Object.setPrototypeOf(B, A);B.prototype.__proto__ === A.prototype // true// 等同于Object.setPrototypeOf(B.prototype, A.prototype); 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 Mixin模式 Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。 1234const a = &#123; const b = &#123; a: &apos;a&apos; b: &apos;b&apos;&#125;; &#125;;const c = &#123;...a, ...b&#125;; // &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125; c对象是a对象和b对象的合成，具有两者的接口 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。 123456789101112131415161718192021function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix.prototype, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 1class DistributedEdit extends mix(Loggable, Serializable) &#123; // ... &#125; 10.SetSet 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是Set中NaN等于自身，而精确相等运算符认为NaN不等于自身。另外，两个对象总是不相等的。 Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 123456789101112131415// 对象的写法const properties = &#123; &apos;width&apos;: 1, &apos;height&apos;: 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add(&apos;width&apos;);properties.add(&apos;height&apos;);if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将 Set 结构转为数组。 1234const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);//这就提供了去除数组重复成员的另一种方法。Array.from(new Set(array)); Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 可以省略values方法，直接用for…of循环遍历 Set。 12345let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x); // red green blue&#125; 扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。 12let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)]; // [3, 5, 2] 实现去重 数组的map和filter方法也可以间接用于 Set 了 12345let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2)); // 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0)); // 返回Set结构：&#123;2, 4&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。 一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。 123456// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2)); // set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2)); // set的值是2, 4, 6 11.MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。 Map“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，是一种更完善的 Hash 结构实现。 1234567const map = new Map([ //新建 Map 实例时，就指定了两个键name和title [&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;Author&apos;]]);map.size // 2map.has(&apos;name&apos;) // truemap.get(&apos;name&apos;) // &quot;张三&quot; 不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。 12345678910const set = new Set([ [&apos;foo&apos;, 1], [&apos;bar&apos;, 2]]);const m1 = new Map(set);m1.get(&apos;foo&apos;) // 1const m2 = new Map([[&apos;baz&apos;, 3]]);const m3 = new Map(m2);m3.get(&apos;baz&apos;) // 3 上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。 如果对同一个键多次赋值，后面的值将覆盖前面的值。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 Map 结构的实例有以下属性和操作方法。 （1）size 属性：返回 Map 结构的成员总数。 （2）set(key, value)：设置键名key对应的键值为value，然后返回整个 Map 结构。 set方法返回的是当前的Map对象，因此可以采用链式写法。 1let map = new Map().set(1, &apos;a&apos;).set(2, &apos;b&apos;).set(3, &apos;c&apos;); （3）get(key)：读取key对应的键值，如果找不到key，返回undefined。 （4）has(key)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。 （5）delete(key)：删除某个键，返回true。如果删除失败，返回false。 （6）clear()：清除所有成员，没有返回值。 Map 结构原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历 Map 的所有成员。 需要特别注意的是，Map 的遍历顺序就是插入顺序。 与其他数据结构的互相转换（1）Map 转为数组：最方便的方法，就是使用扩展运算符（…）。 1234const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);[...myMap] // [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ] （2）数组 转为 Map：将数组传入 Map 构造函数，就可以转为 Map。new Map([]) （3）Map 转为对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。 12345678910function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;//如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名const myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToObj(myMap) // &#123; yes: true, no: false &#125; （4）对象转为 Map 12345678function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;) // Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; （5）Map 转为 JSON Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 123456function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);strMapToJson(myMap) // &apos;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&apos; 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。 123456function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);mapToArrayJson(myMap) // &apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos; （6）JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。 12345function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;) // Map &#123;&apos;yes&apos; =&gt; true, &apos;no&apos; =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。 12345function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;) // Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125; 12.ProxyProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 123456789101112var obj = new Proxy(&#123;&#125;, &#123; //对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为 get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.count = 1 // setting count!++obj.count // getting count! setting count! 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。如果handler没有设置任何拦截，那就等同于直接通向原对象。 同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === &apos;prototype&apos;) &#123; return Object.prototype; &#125; return &apos;Hello, &apos; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === &quot;Hello, foo&quot; // true Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 13.ReflectReflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 123456789// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 1234// 老写法&apos;assign&apos; in Object // true// 新写法Reflect.has(Object, &apos;assign&apos;) // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log(&apos;get&apos;, target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log(&apos;delete&apos; + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log(&apos;has&apos; + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args)：等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args) Reflect.construct(target, args)：等同于new target(…args)，提供了一种不使用new来调用构造函数的方法。 Reflect.get(target, name, receiver)：查找并返回target对象的name属性 Reflect.set(target, name, value, receiver)：设置target对象的name属性等于value Reflect.defineProperty(target, name, desc)：等同于Object.defineProperty，用来为对象定义属性 Reflect.deleteProperty(target, name)：等同于delete obj[name]，用于删除对象的属性。 Reflect.has(target, name)：对应name in obj里面的in运算符 Reflect.ownKeys(target)：返回对象的所有属性 Reflect.isExtensible(target)：对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 Reflect.preventExtensions(target)：对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 Reflect.getOwnPropertyDescriptor(target, name)：等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象 Reflect.getPrototypeOf(target)：用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj) Reflect.setPrototypeOf(target, prototype)：设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。 使用proxy实现观察者模式 观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 1234567891011const person = observable(&#123; name: &apos;张三&apos;, age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = &apos;李四&apos;; // 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 123456789const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125; 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 14.PromisePromise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 12345678const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; //value是resolve传递过来的值 // success&#125;, function(error) &#123; // failure&#125;); 123456789function timeout(ms) &#123; //返回一个promise对象 return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, &apos;done&apos;); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); Promise 新建后就会立即执行。 123456789101112let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;);// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数（放在执行栈最后），将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; 下面是一个用Promise对象实现的 Ajax 操作的例子。 123456789101112131415161718192021222324252627const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); &#125;); return promise;&#125;;getJSON(&quot;/posts.json&quot;).then(function(json) &#123; console.log(&apos;Contents: &apos; + json);&#125;, function(error) &#123; console.error(&apos;出错了&apos;, error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 123456789101112const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数then将会立刻执行。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567let pro = Promise.resolve(); ajaxArray.forEach(ajax =&gt; &#123; pro = pro.then(ajax) //pro产生链式调用 将ajax方法当做成功的回调函数，会立即执行 .then(res =&gt; &#123; data.push(res); &#125;); &#125;); then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。回调函数中会把上一个then中返回的值当做参数值供当前then方法调用。then方法执行完毕后需要返回一个新的值给下一个then调用（没有返回值默认使用undefined）。每个then只可能使用前一个then的返回值。 12345678910111213141516171819202122232425let doSomething = function() &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(&quot;返回值&quot;); &#125;);&#125;;let doSomethingElse = function() &#123; return &quot;新的值&quot;;&#125;;doSomething().then(function() &#123; return doSomethingElse();&#125;).then(resp =&gt; &#123; console.log(resp); //新的值 console.log(&quot;1&quot;);&#125;);doSomething().then(doSomethingElse()).then(resp =&gt; &#123; console.log(resp); //返回值 doSomethingElse()表示函数执行返回的值，是非函数 console.log(&quot;2&quot;);&#125;);doSomething().then(doSomethingElse).then(resp =&gt; &#123; console.log(resp); //新的值 console.log(&quot;3&quot;);&#125;); Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 1234567getJSON(&apos;/post/1.json&apos;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 12345server.listen(port) //服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 .then(function () &#123; // ... &#125;) .finally(server.stop); Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 123456789// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;hello&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;报错了&apos;);&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [&quot;hello&quot;, Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;hello&apos;);&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error(&apos;报错了&apos;);&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 123Promise.resolve(&apos;foo&apos;)// 等价于new Promise(resolve =&gt; resolve(&apos;foo&apos;)) Promise.resolve方法的参数分成四种情况。 （1）参数是一个 Promise 实例：将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象：thenable对象指的是具有then方法的对象，会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 12345const p = Promise.resolve(&apos;Hello&apos;);p.then(function (s)&#123; console.log(s)&#125;);// Hello 返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数：直接返回一个resolved状态的 Promise 对象。 如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。 1234const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）执行栈最后，而不是在下一轮“事件循环”的开始时。 123456789101112setTimeout(function () &#123; console.log(&apos;three&apos;);&#125;, 0);Promise.resolve().then(function () &#123; console.log(&apos;two&apos;);&#125;);console.log(&apos;one&apos;);// one// two// three Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 15.Iterator遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 Iterator 的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 123456789101112131415var it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性。 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象(dom) 对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 123456789101112131415161718192021class RangeIterator &#123; //为对象添加 Iterator 接口 constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; //Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。 [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;let range = new RangeIterator(0,3)for (let value of range) &#123; console.log(value); // 0, 1, 2&#125; 12345678910111213141516171819let obj = &#123; //为对象添加 Iterator 接口 data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 调用 Iterator 接口的场合 （1）解构赋值：对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。 （2）扩展运算符（…）也会调用默认的 Iterator 接口。 12345let set = new Set().add('a').add('b').add('c');let [x,y] = set; // x='a'; y='b'let [first, ...rest] = set; // first='a'; rest=['b','c'];var str = 'hello';[...str] // ['h','e','l','l','o'] 实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 1let arr = [...iterable]; （3）由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() Iterator 接口与 Generator 函数 Symbol.iterator方法的最简单实现，还是使用 Generator 函数。 123456789101112131415161718192021let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// "hello"// "world" for…in循环读取键名，for…of循环读取键值 些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[key, value]组成的数组。对于数组，键名就是索引值； 对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key]);&#125; 另一个方法是使用 Generator 函数将对象重新包装一下。 1234567891011function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value);&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是for循环。这种写法比较麻烦，因此数组提供内置的forEach方法，但是无法中途跳出forEach循环，break命令或return命令都不能奏效。 for…in循环可以遍历数组的键名。for…in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。 1234let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];for(let key in arr)&#123; console.log(Object.prototype.toString.call(key).slice(8,-1)) //String&#125; for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 for…of循环相比上面几种做法，有一些显著的优点。 有着同for…in一样的简洁语法，但是没有for…in那些缺点。 不同于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 16.GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案。Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 12345678910111213141516function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; //return后done变为true，或者执行到结尾done为true&#125;let h = helloWorldGenerator()console.log(h.next()); //&#123; value: &apos;hello&apos;, done: false &#125;console.log(h.next()); //&#123; value: &apos;world&apos;, done: false &#125;console.log(h.next()); //&#123; value: &apos;ending&apos;, done: true &#125;console.log(h.next()); //&#123; value: undefined, done: true &#125;let hw = helloWorldGenerator();for(let key of hw) console.log(key) //hello world 已经遍历完毕，done变为trueconsole.log(hw.next()); //&#123; value: undefined, done: true &#125;console.log(hw.next()); //&#123; value: undefined, done: true &#125; 调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。 return方法跟next方法的区别: 1)return终结遍历，之后的yield语句都失效；next返回本次yield语句的返回值。2)return没有参数的时候，返回{ value: undefined, done: true }；next没有参数的时候返回本次yield语句返回值3)return有参数的时候，覆盖本次yield语句的返回值，也就是说，返回{ value: 参数, done: true }；next有参数的时候，覆盖上次yield语句的返回值，返回值可能跟参数有关（参数参与计算的话），也可能跟参数无关（参数不参与计算）。 12345678910111213141516function* foo(x) &#123; yield "1"; var y = 2 * (yield (x + 1)); var z = yield (y / 3); yield "2"; return (x + y + z);&#125;let next = foo(5);let it = next.next();while (!it.done) &#123; console.log(it.value); //1 6 4 2 it = next.next(it.value);&#125;console.log(next.return(it.value).value); //21 最后输出x+y+z的值console.log(next.return()); //&#123; value: undefined, done: true &#125; 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123function* gen() &#123; yield 123 + 456; //不会立即求值，只会在next方法将指针移到这一句时，才会求值。&#125; Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。 1234567function* f() &#123; console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678910var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;console.log([...myIterable]); // [1, 2, 3] 具有了Iterator接口，可以被扩展运算符遍历for(let value of myIterable)&#123; console.log(value) //1 2 3&#125; yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 12345678910111213function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; a.next()第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 12345678910function* dataConsumer() &#123; console.log('Started'); console.log(`1. $&#123;yield&#125;`); console.log(`2. $&#123;yield&#125;`); return 'result';&#125;let genObj = dataConsumer();genObj.next(); // StartedgenObj.next('a') // 1. agenObj.next('b') // 2. b for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以return语句的返回值不包括在for…of循环之中。 下面是一个利用 Generator 函数和for…of循环，实现斐波那契数列的例子。 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; while (true) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; 利用for…of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for…of循环，通过 Generator 函数为它加上这个接口，就可以用了 123456789101112function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); //将所有key包装成数组 for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 加上遍历器接口的另一种写法是，将 Generator 函数加到对象的Symbol.iterator属性上面。 1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 12345678910111213141516function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符[...numbers()] // [1, 2]// Array.from 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers(); x 1 y 2// for...of 循环for (let n of numbers()) &#123; console.log(n) // 1 2&#125; Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 123456789101112131415function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。如果return方法调用时，不提供参数，则返回值的value属性为undefined。 如果 Generator 函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 如果一个对象的属性是 Generator 函数，可以简写成下面的形式。 12345let obj = &#123; * myGeneratorMethod() &#123;&#125; //等价于 myGeneratorMethod: function* () &#123;&#125;&#125;; Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 （1）异步操作的同步化表达 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 123456789101112function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); //成功回调执行next &#125;);&#125;var it = main();it.next(); 注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield表达式本身是没有值的，总是等于undefined。 （2）控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); 采用 Promise 改写上面的代码。 12345678910Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。 1234567891011function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125; 然后，使用一个函数，按次序自动执行所有步骤。 12345678910scheduler(longRunningTask(initialValue));function scheduler(task) &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125;&#125; 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。 （3）部署 Iterator 接口 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 123456789101112function* iterEntries(obj) &#123; let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) &#123; let key = keys[i]; yield [key, obj[key]]; &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value); // foo 3 bar 7&#125; ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。 回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。 Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 1234567891011121314var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。第二步，协程A执行到一半，进入暂停，执行权转移到协程B。第三步，（一段时间后）协程B交还执行权。第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。 next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next返回值的 value 属性是 Generator 函数向外输出数据；next方法还可以接受参数，向 Generator 函数体内输入数据。Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 123456789101112function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next(); g.throw('出错了'); // Generator 函数体外，使用指针对象的throw方法抛出的错误可以被函数体内的try/catch代码块捕获。 异步任务的封装 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。这段代码非常像同步操作，除了加上了yield命令。 1234567var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。 17.asyncasync函数是 Generator 函数的语法糖 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。asyncReadFile()调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能真正执行，得到最后结果。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 1234567891011function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve(ms), ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; console.log(&apos;start&apos;) await timeout(ms).then(value =&gt; console.log(value)); console.log(value);&#125;asyncPrint(&quot;hello world&quot;, 50); //start 50 hello world 1234567891011121314151617181920const mergePromise = ajaxArray =&gt; &#123; let data = []; let pro = Promise.resolve(); ajaxArray.forEach(ajax =&gt; &#123; pro = pro.then(ajax) //产生链式调用 .then(res =&gt; &#123; data.push(res); &#125;); &#125;); return pro.then(() =&gt; data);&#125;;//等同于const mergePromise = async function(ajaxArray) &#123; let data = []; //因await只能用于 async 声明的函数上下文中, 不能写在forEach内 for (let i = 0; i &lt; ajaxArray.length; i++) &#123; await ajaxArray[i]().then(value =&gt; data.push(value)); &#125; return data; //async返回的是promise对象&#125;; async函数返回一个 Promise 对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 1234async function f() &#123; return 'hello world';&#125;f().then(v =&gt; console.log(v)) // "hello world" async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 12345678async function f() &#123; throw new Error('出错了');&#125;f().then( v =&gt; console.log(v), e =&gt; console.log(e))// Error: 出错了 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 12345678async function f() &#123; return await 123;&#125;f().then(v =&gt; console.log(v)) //await命令的参数是数值123，它被转成 Promise 对象，并立即resolveasync function f() &#123; await Promise.reject('出错了');&#125;f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e)) // 出错了 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。 有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。 1234567async function f() &#123; try &#123; await Promise.reject('出错了'); &#125; catch(e) &#123;&#125; return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v)) // hello world 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 123456async function f() &#123; await Promise.reject('出错了') .catch(e =&gt; console.log(e)); return await Promise.resolve('hello world');&#125;f().then(v =&gt; console.log(v)) // 出错了 hello world 使用注意点第一点，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。如果有多个await命令，可以统一放在try…catch结构中。 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 1234567// 写法一 getFoo和getBar都是同时触发let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 写法二 getFoo和getBar都是同时触发let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise; 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。forEach改为for循环。 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是 Promise 的写法。 12345678910111213141516171819function chainAnimationsPromise(elem, animations) &#123; // 变量ret用来保存上一个动画的返回值 let ret = null; // 新建一个空的Promise let p = Promise.resolve(); // 使用then方法，添加所有动画 for(let anim of animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(elem); &#125;); &#125; // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;);&#125; async 函数的写法 1234567891011async function chainAnimationsAsync(elem, animations) &#123; let ret = null; try &#123; for(let anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如依次远程读取一组 URL，然后按照读取的顺序输出结果。Promise 的写法如下： 1234567891011function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; 上面代码使用fetch方法，同时远程读取一组 URL。每个fetch操作都返回一个 Promise 对象，放入textPromises数组。然后，reduce方法依次处理每个 Promise 对象，然后使用then，将所有 Promise 对象连起来，因此就可以依次输出结果。 123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 1234567891011async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125; 虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。 18.ModuleES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 1234567// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法）生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 1import &#123; stat, exists, readFile &#125; from 'fs'; // ES6模块 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化，不能使用arguments.callee，不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） ES6一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 import命令是编译阶段执行的，在代码运行之前。由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12import &#123;firstName, lastName, year&#125; from './profile.js';import * as circle from './circle'; //整体加载 注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变，不允许修改属性方法。 123456// 默认输出加载export default function crc32() &#123;&#125;import crc32 from 'crc32'; //为匿名函数指定名字// 正常export function crc32() &#123;&#125;;import &#123;crc32&#125; from 'crc32'; import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。Node 的require是运行时加载模块，import命令无法取代require的动态加载功能。require到底加载哪一个模块，只有运行时才知道。import命令做不到这一点。 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第一个差异： CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 123456789// lib.js // main.jsvar counter = 3; var mod = require('./lib');function incCounter() &#123; console.log(mod.counter); // 3 counter++; mod.incCounter();&#125; console.log(mod.counter); // 3module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 1234567891011// lib.js // main.jsvar counter = 3; var mod = require('./lib');function incCounter() &#123; console.log(mod.counter); // 3 counter++; mod.incCounter();&#125; console.log(mod.counter); // 4module.exports = &#123; get counter() &#123; //输出的counter属性实际上是一个取值器函数 return counter &#125;, incCounter: incCounter,&#125;; ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 12345// lib.js // main.jsexport let counter = 3; import &#123; counter, incCounter &#125; from './lib';export function incCounter() &#123; console.log(counter); // 3 counter++; incCounter();&#125; console.log(counter); // 4 12345678// m1.jsexport var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500);// m2.jsimport &#123;foo&#125; from './m1.js';console.log(foo); //barsetTimeout(() =&gt; console.log(foo), 500); //baz ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 1234567// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from './lib';obj.prop = 123; // OKobj = &#123;&#125;; // TypeError 可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS面试整理]]></title>
    <url>%2F2018%2F12%2F20%2FCSS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[CSS动画实现@keyframes：form、to来表示一个动画从哪里开始到哪里结束，相当于我们的另外一种表示方式0%到100%，中间可以添加不同关键帧来写我们想要的变化过程，注意0%不能报百分符号省略到 123456789101112//Firefox:@-moz-keyframes。Opera:@-o-keyframes。Safari和Chrome的是 @-webkit-keyframes@keyframes mymove&#123; from &#123;background-position: 0 0;&#125; to &#123;background-position: -1080px 0;&#125;&#125;@keyframes mymove&#123; 0% &#123;background-position: 0 0;&#125; 30% &#123;background-position: -360px 0;&#125; 60% &#123;background-position: -720px 0;&#125; 90% &#123;background-position: -1080px 0;&#125; 100% &#123;background-position: 0 0;&#125;&#125; 关于animation相关的几个属性的用法： 1、animation-name： 用来定义一个动画的名称 语法： animation-name: none | mymove |多个名字; none为默认值，当属性值是none时，表示没有任何的动画效果。 mymove是由Keyframes创建的动画名 mymove要和Keyframes中的mymove一致，如果不一致,将不能实现任何动画效果；当我们同时给animation添加几个动画的时候，我们只需要用逗号“，”隔开就可以。 2、animation-duration ：指定元素播放动画所持续的时间长 语法： animation-duration: 0 | time time：为数值，单位为秒S，他的默认值为“0”。这个属性跟transition中的transition-duration使用方法是一样的 3、animation-delay： 指定元素动画什么时间开始 语法： animation-delay: time； time：表示的是时间，单位是秒S，默认数值是0。 4、animation-iteration-count： 指定元素播放动画的循环次数 语法： animation-iteration-count: value|infinite； 属性值是1时，是默认值，当属性值是infinite表示的意思是无限循环的。 5、animation-direction：指定元素动画播放的方向 语法： animation-direction: normal|reverse|alternate|alternate-reverse normal：动画的运动形式是正常的，这是默认值。 reverse：动画的播放形式是反向的。 alternate： 动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。 alternate-reverse：动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。 6、animation-timing-function：动画的播放方式 语法： animation-timing-function: ease|ease-in|ease-in-out|linear|cubic-bezier(n,n,n,n)； linear：动画运动的开始和结尾都是匀速的。 ease：默认。动画刚开始的时候速度是慢的，然后加快，最后变慢 ease-in：动画从慢的速度开始。 ease-out：动画从慢的速度结尾。 ease-in-out 动画的开始和结尾都是慢的。 cubic-bezier(n,n,n,n) 在 http:cubic-bezier.com网址当中可以设置自己需要的运动方式 step-start 动画运动的时候从最左边的端点为开始点 step-end 动画运动的时候从最后的端点作为开始点，这个是默认值 7、animation-fill-mode ：当动画不播放时，要应用到元素的样式 语法： animation-fill-mode: none|forwards|backwards none：默认值 forwards：在动画结束后，动画停留在结束的位置 backwards 在动画结束后，动画回到最初的位置 HTML5动画API-requestAnimationFrame使用requestAnimationFrame有什么好处？浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力。 不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲就是，系统每次刷新之前会主动调用requestAnimationFrame中的回调函数，如果系统刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个间隔时间就变成了1000/75=13.3ms。换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 回调函数会被传入一个参数，指示requestAnimationFrame() 开始触发回调函数的当前时间。 1234567891011121314 //-webkit- chrome、safari //-moz- firefo //-ms- IE10 //-o- operawindow.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) &#123; //1秒钟60次（大约每16.7毫秒一次） window.setTimeout(callback, 1000 / 60); &#125;;&#125;)(); 使用requestAnimationFrame的时候，只需反复调用它即可。 12345678910function repeatOften() &#123; // Do whatever window.requestAnimationFrame(repeatOften);&#125;window.requestAnimationFrame(repeatOften);---------------------------------------------(function animloop() &#123; render();//Do whatever requestAnimFrame(animloop);&#125;)(); 123456789101112131415var e = document.getElementById(&quot;e&quot;); var flag = true; var left = 0; function render() &#123; left === 0 ? flag = true : left === 500 ? flag = false : &quot;&quot;; flag ? e.style.left = `$&#123;left++&#125;px` : e.style.left = `$&#123;left--&#125;px`; &#125; render() e.onclick = function() &#123; (function animloop() &#123; render(); requestAnimFrame(animloop); &#125;)(); &#125; cancelAnimationFrame方法用于取消重绘。 12requestID = window.requestAnimationFrame()；window.cancelAnimationFrame(requestID); JavaScript动画API第一个参数，keyframes应该是一个对象数组。每个对象都是我们动画中的一个keyframe。 1234567891011var options = &#123; iterations: Infinity, iterationStart: 0, delay: 0, endDelay: 0, direction: &apos;alternate&apos;, duration: 700, fill: &apos;forwards&apos;, easing: &apos;ease-out&apos;,&#125;element.animate(keyframes, options); 对于我们熟悉CSS动画的人来说，options一些术语与我们习惯的不同。 是easing而不是animation-timing-function 是iterations而不是animation-iteration-count。如果我们希望动画永远重复，是Infinity而不是infinite的。有点混乱，无限不是引用。Infinity是一个JavaScript关键字，而其他值是字符串。 我们使用毫秒而不是秒，对于之前编写过许多JavaScript的人来说，这应该是熟悉的。（你可以在CSS动画中使用毫秒数，但很少有人使用。) 动画对象：.animate()方法不仅仅是动画我们的元素，它也返回一个动画对象。 getAnimations（）方法将返回任何动画对象的数组。即使一个DOM元素只有一个动画应用到它，getAnimations()将始终返回一个数组。我们来抓住那个单一的动画对象来处理。 12var h2 = document.querySelector(&quot;h2&quot;);var myCSSAnimation = h2.getAnimations()[0]; WAAPI为我们提供了两项活动和promises的选择。.finished我们的动画对象的属性将返回在动画结束时解决的promise。以下是上面的例子，就像使用promise一样：myAnimation.finished.then(() =&gt; element.remove()) Promise.all希望有一系列的promises，一旦所有这些promises得到解决，只会运行我们的回调函数。我们已经看到，element.getAnimations()返回一个动画对象数组。我们可以将数组中的所有动画对象映射到每个动画对象.finished上，为我们提供所需的一系列承诺。 1234Promise.all(document.getAnimations().map(animation =&gt; animation.finished)).then(function() &#123; // do something cool &#125;) CSS新特性 颜色：新增RGBA，HSLA模式 文字阴影（text-shadow）文字折行（word-wrap） 边框： 圆角（border-radius）边框阴影： box-shadow 盒子模型：box-sizing 背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局 渐变：linear-gradient、radial-gradient 过渡：transition，可实现动画 自定义动画 在CSS3中唯一引入的伪元素是 ：selection. 媒体查询，多栏布局 border-image 2D转换transform：对元素进行移动、缩放、转动、拉长或拉伸 translate(x，y)移动 rotate(顺时针旋转角度) skew(围绕x，y轴旋转角度) scale(x，y)缩放 3D转换 rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform：rotateX(120deg) rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform：rotateY(120deg) CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个元素 p:last-of-type 选择属于其父元素的最后元素 p:nth-child(2) 选择属于其父元素的第二个子元素 p:nth-last-child(n) ……………………………………….从最后一个子元素开始计数 p:nth-of-type(n) 选择其父元素的n个元素 p:nth-last-of-type(n) ……………………从最后一个子元素开始计数 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 如何区分 HTML 和 HTML5？ 新特性： 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation支持HTML5新标签 盒模型 IE模型和标准模型唯一的区别是内容计算方式的不同： 标准模型元素宽度width=content，高度计算相同 IE模型元素宽度width=content+padding+border，高度计算相同 通过css3新增的属性 box-sizing: content-box | border-box分别设置盒模型为标准模型（content-box）和IE模型（border-box）。 javascript如何设置获取盒模型对应的宽和高 dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。 dom.currentStyle.width/height 取到的是最终渲染后的宽和高，只有IE支持此属性。 window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。 dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离 单位： 百分比：百分比的参照物是父元素，50%相当于父元素width的50% rem：这个对于复杂的设计图相当有用，它是html的font-size的大小 em：它虽然也是一个相对的单位，相对于父元素的font-size， BFC(Block Formatting Context)：块级格式化上下文。BFC决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计可视化布局时，BFC提供了一个环境，HTML元素在这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环境中的布局。 BFC的原理（渲染规则） BFC元素垂直方向的边距会发生重叠。属于不同BFC外边距不会发生重叠。 BFC的区域不会与浮动元素的布局重叠。 BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。 计算BFC高度的时候，浮动元素也会参与计算(清除浮动) 如何创建BFC overflow不为visible; float的值不为none； position的值为absolute或fixed； display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex; 两栏布局1.浮动布局：左侧栏固定宽度向左浮动，右侧主要内容则用margin-left留出左侧栏的宽度，默认宽度为auto，自动填满剩下的宽度。但要保证浮动的div先布局，div写在最前面。 1234567891011121314&lt;div id = &quot;aside&quot;&gt;&lt;/div&gt;&lt;div id = &quot;main&quot;&gt;&lt;/div&gt;div&#123; height:500px;&#125;#aside&#123; width:300px; background-color:yellow; float:left;&#125;#main&#123; background-color:aqua; margin-left:300px;&#125; 右侧固定宽度，左侧自适应则是同理，只要将固定栏右浮动，使用margin-right空出其宽度即可。 123456789#aside&#123; width:300px; background-color:yellow; float:right;&#125;#main&#123; background-color:aqua; margin-right:300px;&#125; 2.浮动布局+负外边距（双飞翼布局的两栏版） 123456789101112131415161718192021&lt;div id = &quot;aside&quot;&gt;&lt;/div&gt;&lt;div id = &quot;main&quot;&gt; &lt;div id = &quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt;div&#123; height:500px;&#125;#aside&#123; width:300px; background-color:yellow; float:left; margin-right:-100%;&#125;#main&#123; width:100%; float:left;&#125;#content&#123; margin-left:300px; background-color:aqua;&#125; 左侧固定栏指定一个右侧的100%的负外边距，为整个屏幕的宽度，这就使得main的最左侧可以与屏幕最左侧对齐。 此时main的宽度是100%，因此需要为其子内容content指定一个左侧的外边距用于空出左侧栏的位置，即左侧栏的宽度300px 3.flex 123456789101112131415161718192021#content &#123; display: flex; &#125; .left &#123; background-color: yellow; height: 200px; flex: 1; &#125; .right &#123; background-color: aqua; height: 200px; width: 100px; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 三栏布局1.绝对定位：左右侧分别用绝对定位固定，中间栏则利用margin-left和margin-right空出左右栏位置。 2.浮动定位法分别另左侧栏和右侧栏向左和向右浮动，中间栏放在最后，再利用左右外边距空出左右栏的位置即可。 1234567891011121314151617181920&lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;!--左右侧栏的位置可以更改--&gt;&lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;div id=&quot;main&quot;&gt;main&lt;/div&gt; &lt;!--中间栏放最后--&gt;&lt;style&gt; #left&#123; width:300px; background-color:yellow; float:left; &#125; #right&#123; width:200px; background-color:orange; float:right; &#125; #main&#123; background-color:aqua; margin-left:300px; margin-right:200px; &#125;&lt;/style&gt; 3.浮动+负外边距（双飞翼布局） 三个栏都采用左浮动； 中间栏的div写在最前面，宽度为100% 左侧栏也是左浮动，默认情况下由于前面的中间栏div占据了100%，因此这个左侧栏是在中间栏下方一行的。为左侧栏设置margin-left:-100%，即整个屏幕的宽度100%，这就令左侧栏跑到了中间栏的最左侧。 右侧栏也是左浮动，此时默认情况下也是在中间栏下方一行的，同样利用margin-left:-300px，即其自身的宽度，使其到上一行最右侧的位置。 中间栏的内容部分则需要利用分别等于左右侧栏宽度的外边距来空出它们的位置。 这种方法的好处就是主体main在前面，可以先加载主题内容。 12345678910111213141516171819202122232425262728&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;content&quot;&gt;content&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;left&quot;&gt;left&lt;/div&gt;&lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;style&gt; #main&#123; background-color:aqua; width:100%; float:left; &#125; #left&#123; width:200px; background-color:yellow; float:left; margin-left:-100%; &#125; #right&#123; width:300px; background-color:orange; float:left; margin-left:-300px; //自身width &#125; #content&#123; margin-left:200px; margin-right:300px; &#125;&lt;/style&gt; 4.圣杯布局 两边固定宽度，中间自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染。三栏全部float:left浮动，并配合left和right属性。 三栏都向左浮动，center的宽度为100%，left的margin-left为-100%，right的margin-left为其自身宽度的负值。 但此时左右边栏实际上是在center上方的，会遮盖center内容。 为container设置一个左右的padding，分别为left和right的宽度。此时整体都是向中间压缩的 对left与right使用position:relative，分别设置left：-自身宽度和right：-自身宽度使其相对现在的位置分别向左、向右移动，从而占据container利用padding空出来的位置。 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .column &#123; float: left; height: 100px; &#125; #center &#123; background-color: #1fc195; width: 100%; &#125; #left &#123; width: 200px; background-color: yellow; margin-left: -100%; position: relative; left: -200px; &#125; #right &#123; width: 300px; background-color: aqua; margin-left: -300px; position: relative; right: -300px; &#125; #container&#123; padding: 0 300px 0 200px; height: 100px; &#125;&lt;/style&gt; 5.flex 12345678910111213141516171819202122&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;style&gt;#container&#123; display: flex;&#125;#left&#123; width: 300px; background-color: yellow;&#125;#center&#123; width: 100%; background-color: #1fc195;&#125;#right&#123; width: 200px; background-color: aqua;&#125;&lt;/style&gt; 水平垂直居中水平居中 设置元素为文本或者图片等行内元素时，可以通过text-align:center实现。 当设置的元素为块状元素时，text-align:center就不起作用了，这时候分两种情况：1) 定宽块状元素通过设置左右 margin 为 auto 即可实现：margin:0 auto; 2) 不定宽块状元素设置 display:inline 方法，然后 text-align:center 实现。显示类型设为行内元素；设置 position:absolute 和 left 50%，将元素左偏移50%； 设置父元素display:flex; justify-content:center; 垂直居中 1.父元素确定高度的单行文本，通过设置 line-height 与 height 相同的值即可完成。 line-height 与 font-size 的计算之差，在 CSS 中称为“行间距”，分为两半，分别加到一个文本内容的顶部和底部。缺点：当文字内容的长度大于块的宽时，就有内容脱离了块。 height:20px;line-height:20px 2.父元素高度确定的块1) 使用 padding-top 和 padding-bottom 来居中。 利用父元素高度减去文本高度，所得的值平分到 top bottom，达到居中的目的。 或父元素设置为：position: relative; 子元素设置为：position: absolute; left: 50%; top: 50%; ​ 然后子元素margin: -自身高一半 0 0 -自身宽一半 ​ 或margin替换为：transform: translate(-50%,-50%); 2) 设置 vertical-align:middle (在父元素设置此样式时，会对 inline-block) 类型的子元素都有用。 ​ 第一种方法：.parent{display:table-cell; vertical-align:middle; height:20px;}​ 第二种方法：.parent{display:inline-block; vertical-align:middle; line-height:20px;} 在 chrome firefox IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell (设置为表格单元显示)，激活 vertical-align 属性，但 IE6 IE7 并不支持。 优点：不用加多余的无意义的标签缺点：兼容性差，且修改了 display 的 block 变成了 table-cell，破坏了原有的块状元素的性质。 4) flex：.parent{display:flex; align-items:center;} 清楚浮动的几种方式浮动带来的问题： 父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素（内联元素）会跟随其后 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。 清除浮动的方式： 父级div定义height 最后一个浮动元素后加空div标签 并添加样式clear:both。 包含浮动元素的父标签添加样式overflow为hidden或auto。 overflow:hidden有一个特点，会将超出的部分隐藏起来，auto超出会出现滚动条。 包含浮动元素的父级div使用伪元素来清除浮动：尽量选择此种方式 IE8以上和非IE浏览器才支持:after，zoom(IE转有属性)可解决ie6,ie7浮动问题 1234567891011.clearfix:after&#123; content:&quot;&quot;;//设置内容为空 height:0;//高度为0 line-height:0;//行高为0 display:block;//将文本转为块级元素 visibility:hidden;//将元素隐藏 clear:both//清除浮动&#125;.clearfix&#123; zoom:1;//为了兼容IE&#125; 使用双伪元素清除浮动 12345678.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: block; clear: both;&#125;.clearfix &#123; zoom: 1;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%20%E4%B8%8B%E5%8D%886.43.58%2F</url>
    <content type="text"><![CDATA[浏览器缓存浏览器的缓存问题，主要指的是http的缓存——即协议层。而h5新增的storage和数据库缓存，那是应用层缓存，并不被计入本篇的分析内容里面。下面我们正式开始来进行缓存的分析。 协议层的缓存，其实，可以被分成强制缓存和对比缓存 强制缓存 只有当缓存失效时，才会去服务器获取最新资源的方式，就是强制缓存。而在协议层的字段中，可以造成强制缓存的字段有两个Expires和Cache-Control。 最早使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。因此，该时间是一个绝对时间，举例说明： 1Expires: Thu, 10 Nov 2017 08:45:11 GMT 在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。 但是，这个字段设置时有缺点：由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源，同时，还导致客户端与服务端的时间不一致，致使缓存失效。 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求 这两者的区别就是前者是绝对时间，而后者是相对时间。我们不妨举个例子来说明一下： 1Cache-Control: max-age=2592000 Cache-Control的字段可以带的值： max-age：即最大有效时间 min-fresh：要求缓存服务器返回至少还未过指定时间的缓存资源 no-cache：表示没有缓存，响应方即告诉浏览器该资源并没有设置缓存，客户端请求方则是强制向源服务器再次验证 no-store：不缓存请求或响应的任何内容 s-maxage：同max-age，只适用于多位用户使用的公共缓存服务器响应的最大Age public：多用户共享缓存，默认设置，表明其他用户也可利用缓存 private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。 总结一下，自从http1.1开始，Expires逐渐被Cache-Control取代。Cache-Control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且Cache-Control的可配置性比较强大。 对比缓存 对比缓存的过程是，先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存；反之，则返回304状态码，告知客户端缓存未更新，可继续使用。 对比缓存主要应用于一些时常需要动态更新的资源文件。协议里的字段是Last-Modified和If-Modified-Since。 Last-Modified：服务器告知客户端，资源最后一次被修改的时间，例如 1Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT If-Modified-Since：再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，如果相等，则表示未修改，响应304；反之，则表示修改了，响应200状态码，返回数据。 这个字段可以和Cache-Control配合使用。 但是他还是有一定缺陷的： 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。 修改时间变了，但实际上文件内容没变 由于Last-modified还是存在缺陷的，尽管大多数情况下，会使用它，但当遇到我们上面所说的场景时，就需要用Etag完善了。 Etag存储的是文件的特殊标识(一般都是hash生成的)，服务器存储着文件的Etag字段，可以在与每次客户端传送If-match的字段进行比较，如果相等，则表示未修改，响应304；反之，则表示已修改，响应200状态码，返回数据。 浏览器的行为会产生怎样的请求： 刷新网页 =&gt; 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据 手动刷新（F5） =&gt; 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。 强制刷新（Ctrl + F5） =&gt; 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。 分级缓存策略200状态 from cache 由expires/cache-control控制 ​ expires是绝对时间 cache-control相对时间优先级&gt;expires ​ 只要未失效，浏览器只访问自己的缓存，不向服务器发请求 304 客户端服务端协商过程 由last-modified/Etag控制 Etag&gt;last-modified ​ 当上一层失效，或是用户点击F5、refresh，浏览器发送请求给服务端 ​ 如果服务端没有变化，返回304给浏览器，从缓存中读取 200 上一层发现内容更新、当浏览器本地没有缓存或上一级失效时，或用户点击Ctrl+F5 ​ 浏览器向服务端发送请求，从服务端获取数据 HTTPxhr.status=200 statusText = ‘OK’ xhr.readyState = 4 返回结果的HTTP状态码：状态码告知从服务器返回的请求结果 1xx 信息型状态码 接收的请求正在处理 2xx 成功型状态码 请求正常处理完毕 3xx 重定向状态码 需要进行附加操作以完成请求 4xx 客户端错误状态码 服务器无法处理请求 5xx 服务端错误状态码 服务器处理请求错误 2xx 表明处理被正常请求成功 200 OK 表示从客户端发来的请求在服务器端被正常处理 204 No Content 请求处理成功，但没有资源可返回，浏览器显示的页面不发生更新 206 Partial Content 客户端Content-Range指定范围请求，服务端成功执行了这部分GET请求 3xx 表明浏览器需要执行某些特殊的处理以正确处理请求 301 永久性重定向 表明请求的资源已被分配了新的URL 302 临时性重定向 表示本次能使用新的URL访问 303 表示由于请求对应的资源存在另一个URL，应使用GET方法定向获取请求资源 304 Not Modified 表示客户端发送附带缓存条件请求时，服务端允许请求访问资源，但未满足条件的情况 4xx 表明客户端是发生错误的原因 400 Bad Request 请求报文中存在错误 401 Unauthorized 表示发送的请求需要有通过HTTP认证的认证信息 返回401响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。当浏览器初次接收401响应会弹出认证用的对话窗口 403 表明了对请求资源的访问被服务器拒绝了 404 Not Found 表明服务器上无法找到请求的资源 5xx 表明服务器本身发生错误 500 表明服务器端在执行请求时发生了错误 503 表明服务器暂时处于超负载或停机维护，现在无法处理请求 HTTP报文首部 在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段三部分构成。 通用首部字段：请求、响应报文都有 connection：控制不再转发给代理的首部字段、管理持久连接 Connection：Upgrade 通过代理服务器以后首部字段Upgrade被删除后再转发 HTTP/1.1默认连接都是持久连接（之前版本不是），要在旧版本的HTTP协议上维持持续连接，需要指定首部字段Connection：Keep-Alive 客户端会在持久连接上持续发送请求，当服务器端想明确断开连接时，指定Connection：close Via首部字段为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。Via还可避免请求回环的发生，所以必须在经过代理时添加该首部字段内容。 实体首部字段：请求、响应报文都有 请求首部字段 If-Range字段值若是跟ETag值或更新的日期时间匹配一致，那么就作为范围请求处理，指定范围Range：bytes=5001-10000。若不一致，则忽略范围请求，返回全部资源。 响应首部字段： 为cookie服务的首部字段 Set-Cookie字段的属性 HTTPS=HTTP+ 加密 + 认证 + 完整性保护HTTP的不足： 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 1.通信使用明文可能会被窃听 HTTP本身不具备加密的功能，所以也无法做到对通信整体进行加密，即HTTP报文使用明文方式发送。TCP/IP是可能被窃听的网络。 加密处理防止被窃听 通信的加密 一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。 用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中 没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送 请求。 2.不验证通信方的身份就可能遭遇伪装 任何人都可发起请求：在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何 人都可以发起请求。另外，服务器只要接收到请求，不管对方是 谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没 有被 Web 服务器设定限制访问的前提下）。 查明对手的证书：虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。 SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是 实际存在的。通过使用证书，以证明通信方就是意料中的服务器。这对使用者 个人来讲，也减少了个人信息泄露的危险性。 3.无法证明报文完整性， 可能已遭篡改 接收到的内容可能有误：由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响 应送出之后直到对方接收之前的这段时间内，即使请求或响应的 内容遭到篡改，也没有办法获悉。 换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请 求 / 响应是前后相同的。比如，从某个 Web 网站上下载内容，是无法确定客户端下载的 文件和服务器上存放的文件是否前后一致的。文件内容在传输途 中可能已经被篡改为其他的内容。即使内容真的已改变，作为接 收方的客户端也是觉察不到的。 HTTP+ 加密 + 认证 + 完整性保护=HTTPS HTTPS通信 步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包 含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所 使用的加密算法及密钥长度等）。 步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。 步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。 步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL 握手协商部分结束。 步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。 步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。 步骤 8： 服务器同样发送 Change Cipher Spec 报文。 步骤 9： 服务器同样发送 Finished 报文。 步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接 就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。 步骤 11： 应用层协议通信，即发送 HTTP 响应。 步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。 在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。 HTTP性能瓶颈1.消除 HTTP 瓶颈的 SPDY：旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间 （50%） HTTP 标准的瓶颈。 一条连接上只可发送一个请求。 请求只能从客户端开始。 客户端不可以接收除响应以外的指 令。 请求 / 响应首部未经压缩就发送。 首部信息越多延迟越大。 发送冗长的首部。 每次互相发送相同的首部造成的浪费较 多。 可任意选择数据压缩格式。 非强制压缩发送。 Ajax 的解决方法 从已 加载完毕的 Web 页面上发起请求，以达到局部 Web 页面替换加载的异步通信手 段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输 的数据量会因此而减少。而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产 生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。 SPDY 的设计与功能 SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之 间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规 定通信中使用 SSL。 SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、 Cookie 以及 HTTP 报文等。 使用 SPDY 后，HTTP 协议额外获得以下功能。 多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。 赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。 压缩 HTTP 首部：压缩请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。 推送功能：支持服务器主动向客户端推送数据的功能。服务器可直接发送数据而不必等待客户端的请求。 服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源 之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。 2.使用浏览器进行全双工通信的 WebSocket 为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。 一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接， 之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。 由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方 都可直接向对方发送报文。 WebSocket 协议的主要特点。 推送功能：支持由服务器向客户端推送数据的推送功能。这样服务器可直接发送数据，而不必等待客户端的请求。 减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相 比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一 次“握手”（Handshaking）的步骤。 握手·请求：为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字 段，告知服务器通信协议发生改变，以达到握手的目的。 12345GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。 Sec-WebSocket-Protocol 字段内记录使用的子协议。 子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接 的名称。 握手·响应：对于之前的请求，返回状态码 101 Switching Protocols 的响应。 12345HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat Sec-WebSocket-Accept 的字段值是由握手请求中的 SecWebSocket-Key 的字段值生成的。 成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数 据帧，而采用 WebSocket 独立的数据帧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[同源策略和跨域]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%20%E4%B8%8B%E5%8D%886.44.44%2F</url>
    <content type="text"><![CDATA[JS中几种跨域的方式 JSONP 使用XMLHttpRequest对象跨域获取数据：CORS html5的postMessage和onmessage Cookie 和 iframe 窗口通过设置document.domain window.name 属性 同源策略和跨域同源策略限制范围 （1） Cookie、LocalStorage 和 IndexDB 无法读取。 （2） DOM 无法获得。 （3） AJAX 请求不能发送。 规避上面三种限制1.cookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 12345document.domain = &apos;example.com&apos;; //现在，A网页通过脚本设置一个 Cookie。document.cookie = &quot;test1=hello&quot;; //B网页就可以读到这个 Cookie。var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 2.iframe如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。比如，父窗口想获取子窗口的DOM，如果iframe窗口不是同源，就会报错。 document.getElementById(“myIFrame”).contentWindow.document// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. 反之亦然，子窗口获取主窗口的DOM也会报错。 window.parent.document.body // 报错如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。 对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。 1 片段识别符片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL + &apos;#&apos; + data;document.getElementById(&apos;myIFrame&apos;).src = src; 子窗口通过监听hashchange事件得到通知。 12345678window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125;//同样的，子窗口也可以改变父窗口的片段标识符。parent.location.href= target + &quot;#&quot; + hash; 2 window.name浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 window.name = data;接着，子窗口跳回一个与主窗口同域的网址。location = ‘http://parent.url.com/xxx.html&#39;; 然后，主窗口就可以读取子窗口的window.name了。 var data = document.getElementById(‘myFrame’).contentWindow.name;这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 3 window.postMessage上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。 这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。 12var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;); postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。 父窗口和子窗口都可以通过message事件，监听对方的消息。 123window.addEventListener(&apos;message&apos;, function(e) &#123; console.log(e.data);&#125;,false); message事件的事件对象event，提供以下三个属性。 event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 4 LocalStorage通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 12345678910//主窗口写入iframe子窗口的localStorage//子窗口将父窗口发来的消息，写入自己的LocalStorage。window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) &#123; //event.origin属性可以过滤不是发给本窗口的消息 return; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key, JSON.stringify(payload.data));&#125;; 3.ajax同源政策规定，AJAX请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 1 JSONP​ 基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 （1）首先在客户端注册一个callback, 然后把callback的名字传给服务器。（2）此时，服务器先生成 json 数据。然后以 javascript 语法的方式，生成一个function , function 名字就是传递上来的参数 。（3）最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。（4）客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里.（动态执行回调函数） 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 1foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot; &#125;); 由于script元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 2 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 浏览器发出的WebSocket请求的头信息有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出回应。 3 CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写，是跨源AJAX请求的根本解决方法。 相比JSONP只能发GET请求，CORS允许任何类型的请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一：HEAD GET POST （2）HTTP的头信息不超出以下几种字段： ​ Accept​ Accept-Language​ Content-Language​ Last-Event-ID​ Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段，用来说明本次请求来自哪个源（协议+域名+端口），服务器根据这个值来决定是否同意这次请求。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 ​ GET /cors HTTP/1.1​ Origin: http://api.bob.com​ Host: api.alice.com​ Accept-Language: en-US​ Connection: keep-alive​ User-Agent: Mozilla/5.0… 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 ​ Access-Control-Allow-Origin: http://api.bob.com​ Access-Control-Allow-Credentials: true​ Access-Control-Expose-Headers: FooBar​ Content-Type: text/html; charset=utf-8上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 withCredentials 属性 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭 12withCredentials。xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 域的概念二级域名与一级域名的区别：二级域名是依附在一级域名的存在而存在的，也就是说顶级域名消失了，二级域名也会不复存在，反而来说，二级域名网站不做了，主域名不受影响的。 作用： 1.一级域名又称为顶级域名，大家需要注意的是，www.lisp.com这种形式的域名并不是一级域名，它只是一个二级域名，也就是说www只是一个主机名 真正的一级域名是由一个合法的字符串+域名后缀组成，所以，lisp.com这种形式的域名才是一级域名，lisp是域名主体，.com是域名后缀，可以是.net也是域名后缀 所谓的二级域名实际就是一个一级域名下面的主机名，顾名思义，它是在一级域名前面加上一个字符串，比如asdx.lisp.com，它可以拥有与根顶级域名同样的功能，并且通过设置，可以拥有和跟顶级域名完全一样的功能 网址构成： 第一部分协议 ：http第二部分：主机名.也就是www第三部分：申请的申请的域名.baidu.com第四部分：文件名.index.html.因为服务器设置的可以使用默认文件名.所以可以省略.但并不是没有.例如：http://www.baidu.com/index.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue内部运行机制]]></title>
    <url>%2F2018%2F12%2F20%2FVue%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1.Vue.js 运行机制全局概览 初始化及挂载在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。 template 模板编译compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。 ​ parse：会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。 ​ optimize：主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面 时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。 ​ generate：是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。 响应式这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。 Virtual DOMrender function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 123456789&#123; tag: &apos;div&apos;, /*说明这是一个div标签*/ children: [ /*存放该标签的子节点*/ &#123; tag: &apos;a&apos;, /*说明这是一个a标签*/ text: &apos;click me&apos; /*标签的内容*/ &#125; ]&#125; //渲染后 &lt;div&gt; &lt;a&gt;click me&lt;/a&gt; &lt;/div&gt; 更新视图在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。 那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。 2.响应式系统的基本原理Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「响应式系统」。 12345678/* Object.defineProperty obj: 目标对象 prop: 需要操作的目标对象的属性名 descriptor: 描述符 return value 传入对象*/Object.defineProperty(obj, prop, descriptor) 实现 observer（可观察的）使用Object.defineProperty使对象变成可观察的，这一步在 init 的阶段会进行初始化，对数据进行「响应式化」。通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程） 123456789function observer (value) &#123; if (!value || (typeof value !== &apos;object&apos;)) &#123; return; &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]); &#125;);&#125; 响应式系统的依赖收集追踪原理「依赖收集」会让 数据知道有哪些地方依赖我的数据，变化的时候需要通知它们。最终会形成数据与视图的一种对应关系，如下图。 订阅者 Dep订阅者 Dep的主要作用是用来存放 Watcher 观察者对象 123456789101112131415161718class Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs = []; &#125; /* 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作； */ addSub (sub) &#123; this.subs.push(sub); &#125; /* 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作 */ notify () &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;) &#125;&#125; 观察者 Watcher123456789101112class Watcher &#123; constructor () &#123; /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this; &#125; /* 更新视图的方法 */ update () &#123; console.log(&quot;视图更新啦～&quot;); &#125;&#125;Dep.target = null; 依赖收集接下来我们修改一下 defineReactive 以及 Vue 的构造函数，来完成依赖收集。 我们在闭包中增加了一个 Dep 类的对象，用来收集 Watcher 对象。在对象被「读」的时候，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果当该对象被「写」的时候，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。 123456789101112131415161718192021222324252627282930function defineReactive (obj, key, val) &#123; /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */ dep.addSub(Dep.target); return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */ dep.notify(); &#125; &#125;);&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); /* 在这里模拟render的过程，为了触发test属性的get函数 */ console.log(&apos;render~&apos;, this._data.test); &#125;&#125; 小结首先在 observer 的过程中会注册 get 方法，该方法用来进行「依赖收集」。在它的闭包中会有一个 Dep 对象，这个对象用来存放 Watcher 对象的实例。其实「依赖收集」的过程就是把 Watcher 实例存放到对应的 Dep 对象中去。get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）方法，在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。 这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个： ​ 1.触发 get 方法；​ 2.新建一个 Watcher 对象。这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」。其主要就是 get 进行「依赖收集」。set 通过观察者来更新视图。 3.数据状态更新时的差异 diff 及 patch 机制patch首先说一下 patch 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 patch 的过程，我们需要将他们进行比对。 diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。 这张图中的相同颜色的方块中的节点会进行比对，比对得到「差异」后将这些「差异」更新到视图上。因为只进行同层级的比对，所以十分高效。 patch 的过程1234567891011121314function patch (oldVnode, vnode, parentElm) &#123; if (!oldVnode) &#123; addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; else if (!vnode) &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); &#125; else &#123; if (sameVnode(oldVNode, vnode)) &#123; patchVnode(oldVNode, vnode); &#125; else &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; &#125;&#125; 因为 patch 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。 1.首先在 oldVnode（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 addVnodes 将这些节点批量添加到 parentElm 上。同理，在 vnode（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 removeVnodes 进行批量的节点删除即可。 2.当 oldVNode 与 vnode 都存在的时候，需要判断它们是否属于 sameVnode（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。 sameVnode只有当 key、 tag、 isComment（是否为注释节点）、 data同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改input类型，所以他们被视为不同类型）即可。 patchVnode：这个函数是在符合 sameVnode 的条件下触发的，所以会进行「比对」。 1234567891011121314151617181920212223242526272829303132333435function patchVnode (oldVnode, vnode) &#123; //1.在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉 if (oldVnode === vnode) &#123; return; &#125; //2.当新老 VNode 节点都是 isStatic（静态的），并且 key 相同时，只要将 componentInstance 与 elm 从老 VNode 节点“拿过来”即可。 if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123; vnode.elm = oldVnode.elm; vnode.componentInstance = oldVnode.componentInstance; return; &#125; const elm = vnode.elm = oldVnode.elm; const oldCh = oldVnode.children; const ch = vnode.children; //3.当新 VNode 节点是文本节点的时候，直接用 setTextContent 来设置 text if (vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text); &#125; else &#123; //4.新 VNode 节点是非文本节点当时候 if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123; //新老节点children都存在且不相同时 updateChildren(elm, oldCh, ch); //更新子节点 &#125; else if (ch) &#123; //只有 ch 存在的时候，如果old是文本节点则先将节点的文本清除，然后将 ch 批量插入到节点elm下。 if (oldVnode.text) nodeOps.setTextContent(elm, &apos;&apos;); addVnodes(elm, null, ch, 0, ch.length - 1); &#125; else if (oldCh) &#123; //当只有 oldch 存在时，说明需要将老节点通过 removeVnodes 全部清除 removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (oldVnode.text) &#123; //只有老节点是文本节点的时候，清除其节点文本内 nodeOps.setTextContent(elm, &apos;&apos;) &#125; &#125;&#125; updateChildren 首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。 接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) 4.批量异步更新DOM策略及 nextTick 原理12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; test: &apos;begin&apos; &#125;; &#125;, methods () &#123; handleClick () &#123; this.test = &apos;end&apos;; console.log(this.$refs.test.innerText);//打印的是“begin” &#125; &#125;&#125; 当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。 当异步执行update的时候，会调用queueWatcher函数。 Vue.js 在我们修改 data 中的数据后修改视图的过程：“setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图”。 Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象并不是立即更新视图，而会被 push 进一个队列 queue 中，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，id重复的Watcher不会被多次加入到queue中去。等待下一个tick时，这些Watch对象才会被遍历取出。在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。 使用Vue.js的global API的$nextTick方法，即可访问真实DOM节点更新后的数据 123456789methods () &#123; handleClick () &#123; this.test = &apos;end&apos;; this.$nextTick(() =&gt; &#123; console.log(this.$refs.test.innerText);//打印&quot;end&quot; &#125;); console.log(this.$refs.test.innerText);//打印“begin” &#125; &#125; 为什么要异步更新视图123456789101112export default &#123; data () &#123; return &#123; test: 0 &#125;; &#125;, created () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.test++; &#125; &#125;&#125; 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 nextTickVue.js 实现了一个 nextTick 函数，是一个立即执行函数,返回一个queueNextTick接口。 nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。 用 setTimeout 来模拟这个方法，首先定义一个 callbacks 数组用来存储 nextTick，在下一个 tick 处理这些回调函数之前，所有的 cb 都会被存在这个 callbacks 数组中。pending 是一个标记位，代表一个等待的状态。 setTimeout 会在 task 中创建一个事件 flushCallbacks ，flushCallbacks 则会在执行时将 callbacks 中的所有 cb 依次执行。 1234567891011121314151617181920let callbacks = [];let pending = false;function nextTick (cb) &#123; callbacks.push(cb); if (!pending) &#123; pending = true; setTimeout(flushCallbacks, 0); &#125;&#125;function flushCallbacks () &#123; pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; 第一个例子中，当我们将 number 增加 1000 次时，先将对应的 Watcher 对象给 push 进一个队列 queue 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？ 因为 number 执行 ++ 操作以后对应的 Watcher 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 Watcher 对象去修改界面，而是只需要执行一个 Watcher 对象，使其将界面上的 0 变成 1000 即可。 那么，我们就需要执行一个过滤的操作，同一个的 Watcher 在同一个 tick 的时候应该只被执行一次，也就是说队列 queue 中不应该出现重复的 Watcher 对象。 那么我们给 Watcher 对象起个名字吧～用 id 来标记每一个 Watcher 对象，让他们看起来“不太一样”。 实现 update 方法，在修改数据后由 Dep 来调用， 而 run 方法才是真正的触发 patch 更新视图的方法。 123456789101112131415161718192021222324252627282930313233let uid = 0;class Watcher &#123; constructor () &#123; this.id = ++uid; &#125; update () &#123; console.log(&apos;watch&apos; + this.id + &apos; update&apos;); queueWatcher(this); &#125; run () &#123; console.log(&apos;watch&apos; + this.id + &apos;视图更新啦～&apos;); &#125;&#125;let has = &#123;&#125;;let queue = [];let waiting = false;function queueWatcher(watcher) &#123; const id = watcher.id; if (has[id] == null) &#123; has[id] = true; queue.push(watcher); if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue); &#125; &#125;&#125; 我们使用一个叫做 has 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 Watcher 对象 （这样比每次都去遍历 queue 效率上会高很多）。 如果目前队列 queue 中还没有这个 Watcher 对象，则该对象会被 push 进队列 queue 中去。 waiting 是一个标记位，标记是否已经向 nextTick 传递了 flushSchedulerQueue 方法，在下一个 tick 的时候执行 flushSchedulerQueue 方法来 flush 队列 queue，执行它里面的所有 Watcher 对象的 run 方法。 123456789101112function flushSchedulerQueue () &#123; let watcher, id; for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; id = watcher.id; has[id] = null; watcher.run(); &#125; waiting = false;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.从浏览器发起请求到页面能正常浏览都有哪些阶段预处理——&gt;DNS解析——&gt;建立连接——&gt;发起请求——&gt;等待响应——&gt;接受数据——&gt;处理元素——&gt;布局渲染 1.应用层DNS域名解析 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表，没有的话再向浏览器默认的DNS服务器发送查询请求并且同时缓存，请求上级DNS服务器，直至找到或到根节点） 浏览器将端口号从URL中解析出来 2.浏览器与网站建立TCP连接​ 浏览器利用ip直接网站主机通信，浏览器发出TCP连接请求，主机返回TCP应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认，浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP连接建立完成。 3.浏览器发起请求​ 浏览器向主机发起一个HTTP-GET方法报文请求，请求中包含访问的URL，还有User-Agent用户浏览器操作系统信息，编码等，值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件，Cookies如果是首次访问，会提示服务器简历用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 4.服务器接收数据并响应请求​ 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。 ​ 服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后在响应报文中Location项找到重定向地址，浏览器重新访问。 ​ 根据请求报文头Content-type返回资源。 5.页面渲染 HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 具体计算每个 DOM 元素最终在屏幕上显示的大小和位置,web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。 Painting 根据计算好的信息绘制整个页面. 包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。 Composite 渲染层合并 对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。 层(GraphicsLayer)是作为纹理(texture)上传给 GPU 的，现在经常能看到说 GPU 硬件加速，就和所谓的层的概念密切相关。 脚本处理： 浏览器解析文档，当遇到script标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 defer或者async。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。 呈现树（Render Tree）Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。呈现器是和 DOM 元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。 布局Layout 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 2.前端优化目的从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ; 第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。 页面级别的优化：1.减少Http请求 最基本有效的方式​ 一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。 时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 另外，由于浏览器进行并发请求的请求数是有上限的 ，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象。 减少 HTTP请求数的主要途径包括： ​ 1.保持页面简洁、减少资源的使用时最直接的 ​ 2.合理设置 HTTP缓存 ​ 3.资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个 ​ CSS Sprites:合并 CSS图片，减少请求数 ​ 4.懒加载 Lazy Load Images：能在某些条件下或者页面刚加载时减少 HTTP请求数 2.将外部脚本置底（将脚本内容在页面信息内容加载后再加载）​ 浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。 ​ 将 CSS放在 HEAD中 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟 3.Lazy Load Javascript​ 框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。 目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。最初只加载核心模块，其他模块可以等到需要使用的时候才加载。 结合vue2中组件懒加载 代码级优化：1.JavaScript DOM​ 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。 2.避免回流和重绘 reflow repaint：频繁触发重绘和回流会导致UI频繁渲染​ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。当页面布局和几何属性改变时就需要回流 ​ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 ​ 回流必将引起重绘，而重绘不一定会引起回流。 触发页面重布局的属性： 盒子模型相关属性会触发重布局 ​ 定位属性及浮动也会触发重布局 ​ 改变节点内部文字结构也会触发重布局 优化： 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择 对于动画新建图层 启用 GPU 硬件加速 将频繁重绘和回流的Dom元素单独作为一个独立图层，这个Dom元素的重绘和回流的影响只会在这个图层上 3.性能优化的具体方法（way）一）内容层面1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名） 2、避免重定向（/还是需要的） 3、切分到多个域名 4、杜绝404 二）网络传输阶段1、减少传输过程中实体的大小 ​ 1）缓存 ​ 2）cookie优化 ​ 3）文件压缩（Accept-Encoding：g-zip） 2、减少请求的次数 ​ 1）文件适当的合并 ​ 2）雪碧图 3、异步加载（并发,requirejs） 4、预加载、延后加载、按需加载 三）渲染阶段1、js放底部，css放顶部 2、减少重绘和回流 ​ 3、合理使用Viewport 等meta头部 ​ 4、减少dom节点 ​ 5、BigPipe 四）脚本执行阶段1、缓存节点，尽量减少节点的查找 2、减少节点的操作（innerHTML） 3、避免无谓的循环，break、continue、return的适当使用 4、事件委托 4.高性能滚动优化及渲染优化网页生成的时候，至少会渲染（Layout+Paint）一次。用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）。其中，用户 scroll 和 resize 行为（即是滑动页面和改变窗口大小）会导致页面不断的重新渲染。 当滚动页面时，浏览器可能会需要绘制层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。 scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流。 防抖（Debouncing）防抖即是是在一定时间内，只在最后一次被触发时，执行处理函数。 12345678910111213141516// 简单的防抖动函数function debounce(func, wait, immediate) &#123; var timeout; // 定时器变量 return function() &#123;//闭包避免timeout变为全局变量 clearTimeout(timeout); // 每次触发 scroll handler 时先清除定时器 timeout = setTimeout(func, wait); // 指定 xx ms 后触发真正想进行的操作 handler &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction realFunc()&#123; console.log(&quot;Success&quot;);&#125;// 采用了防抖动window.addEventListener(&apos;scroll&apos;,debounce(realFunc,500));// 没采用防抖动window.addEventListener(&apos;scroll&apos;,realFunc);//scroll只要改变立即操作handler 封装防抖 123456789101112131415161718// 防抖动函数function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // 滚动中的真正的操作&#125;, 250);window.addEventListener(&apos;resize&apos;, myEfficientFn);// 绑定监听 节流（Throttling）防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 避免处理函数被频繁的触发，让函数每隔一段时间执行一次，当在执行周期内被触发时，不允许被执行。 当触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。并且节流函数多了一个 mustRun 属性，代表 mustRun 毫秒内，必然会触发一次 handler ，同样是利用定时器。 123456789101112131415161718192021// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout,startTime = new Date(); return function() &#123; var context = this,args = arguments,curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args);//触发handler startTime = curTime; &#125;else&#123;// 没达到触发间隔，重新设定定时器 timeout = setTimeout(func, wait); &#125; &#125;;&#125;;function realFunc()&#123;// 实际想绑定在 scroll 事件上的 handler console.log(&quot;Success&quot;); &#125;// 采用了节流函数window.addEventListener(&apos;scroll&apos;,throttle(realFunc,500,1000));//如果在一段时间内 scroll 触发的间隔一直小于500ms ，保证 handler 在 1000ms 内至少触发一次]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[正则表达式核心是 匹配，匹配位置或者匹配字符 基本元字符 . ： 匹配除了换行符之外的任何单个字符 \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\*/ 将 ‘‘ 的特殊性移除，从而可以匹配像 `”a“` 这样的字符串。 | ： 逻辑或操作符 [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身 [^]：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \$ ： 匹配表达式的结束 \b：匹配单词边界 \B：匹配非单词边界 (?=p)：匹配 p 前面的位置 (?!p)：匹配不是 p 前面的位置 特殊元字符 \d：[0-9]，表示一位数字，记忆方式 digit \D：[^0-9]，表示一位非数字 \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character \S：[^\t\v\n\r\f]，表示非空白符 \w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word \W：[^0-9a-zA-Z]，表示非单词字符 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 match接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 12345678910var str = &apos;For more information, see Chapter 3.4.5.1&apos;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;]// &apos;see Chapter 3.4.5.1&apos; 是整个匹配。// &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。// &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。// &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。// &apos;input&apos; 属性是被解析的原始字符串。复制代码 12345var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replace接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);// newString abc - 12345 - #$*% split 接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test：接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec：同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input 同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。 有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的”hello”这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪: 默认贪婪 123var regex = /\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\d\D\s\S\w\W)都可以等价成这种。比如 123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 匹配保留2位小数的数字/^([1-9]\d*|0)(\.\d{1,2})?$/ 电话号码/(\+86)?1\d{10}/ 身份证/^(\d{15}|\d{17}([xX]|\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o*， *代表位置 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \w([a-zA-Z0-9_]) 和 \W 之间的位置，包括 \w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\b/g, &#39;#&#39;) 结果是 #hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 ‘’，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\Be\Bl\Bl\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\B\B\Be\Bl\Bl\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子：千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 ‘,’ 就好了，写成正则就是123123213.replace(/(?=(\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 ‘,’ 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\d(?=(\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 ‘,’ 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组：主要是括号的使用分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\d{4}-\d{2}-\d{2}/，这个正则还可以改成分组形式的/(\d{4})-(\d{2})-(\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以 1234var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 捕获组编号：按照普通捕获组中“(”出现的先后顺序，从左到右，从1开始进行编号 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 反向引用的作用通常是用来查找或限定重复，限定指定标识配对出现等等。 对于普通捕获组语法如下：JavaScript不支持命名捕获组,所以对于捕获组的引用就只支持普通捕获组的反向引用和$number方式的引用. 普通捕获组反向引用：\k&lt;number&gt;，通常简写为\number。number是十进制的数字，即捕获组的编号。 1234//替换掉html标签中的属性 var data = &quot;&lt;table id=\&quot;test\&quot;&gt;&lt;tr class=\&quot;light\&quot;&gt;&lt;td&gt; test &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;var reg = /&lt;([a-z]+)[^&gt;]*&gt;/ig;console.log(data.replace(reg, &quot;&lt;$1&gt;&quot;)); //replace中使用 之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种 1232017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\d{4})[-/.](\d{2})[-/.](\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\d{4})([-/.])(\d{2})\2(\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\d)(\d(\d)))\1\2\3\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\1就匹配\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 ‘abbbc’ 和这么一个正则 /ab{1,3}bbc//ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法” 贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;) 前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。操作符： 转义符 \ 括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f, g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是]]></content>
  </entry>
</search>
