<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.从浏览器发起请求到页面能正常浏览都有哪些阶段预处理——&gt;DNS解析——&gt;建立连接——&gt;发起请求——&gt;等待响应——&gt;接受数据——&gt;处理元素——&gt;布局渲染 1.应用层DNS域名解析 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表，没有的话再向浏览器默认的DNS服务器发送查询请求并且同时缓存，请求上级DNS服务器，直至找到或到根节点） 浏览器将端口号从URL中解析出来 2.浏览器与网站建立TCP连接​ 浏览器利用ip直接网站主机通信，浏览器发出TCP连接请求，主机返回TCP应答报文，浏览器收到应答报文发现ACK标志位为1，表示连接请求确认，浏览器返回TCP（）确认报文，主机收到确认报文，三次握手，TCP连接建立完成。 3.浏览器发起请求​ 浏览器向主机发起一个HTTP-GET方法报文请求，请求中包含访问的URL，还有User-Agent用户浏览器操作系统信息，编码等，值得一提的是Accep-Encoding和Cookies项。Accept-Encoding一般采用gzip，压缩之后传输html文件，Cookies如果是首次访问，会提示服务器简历用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。 4.服务器接收数据并响应请求​ 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。 ​ 服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后在响应报文中Location项找到重定向地址，浏览器重新访问。 ​ 根据请求报文头Content-type返回资源。 5.页面渲染 HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 具体计算每个 DOM 元素最终在屏幕上显示的大小和位置,web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。 Painting 根据计算好的信息绘制整个页面. 包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。 Composite 渲染层合并 对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。 层(GraphicsLayer)是作为纹理(texture)上传给 GPU 的，现在经常能看到说 GPU 硬件加速，就和所谓的层的概念密切相关。 脚本处理： 浏览器解析文档，当遇到script标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 defer或者async。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM Tree和Style Rules上。 呈现树（Render Tree）Render Tree的构建其实就是DOM Tree和CSSOM Attach的过程。呈现器是和 DOM 元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。 布局Layout 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 2.前端优化目的从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ; 第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。 页面级别的优化：1.减少Http请求 最基本有效的方式​ 一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。 时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。 另外，由于浏览器进行并发请求的请求数是有上限的 ，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象。 减少 HTTP请求数的主要途径包括： ​ 1.保持页面简洁、减少资源的使用时最直接的 ​ 2.合理设置 HTTP缓存 ​ 3.资源合并与压缩：如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个 ​ CSS Sprites:合并 CSS图片，减少请求数 ​ 4.懒加载 Lazy Load Images：能在某些条件下或者页面刚加载时减少 HTTP请求数 2.将外部脚本置底（将脚本内容在页面信息内容加载后再加载）​ 浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。 ​ 将 CSS放在 HEAD中 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟 3.Lazy Load Javascript​ 框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。 目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。最初只加载核心模块，其他模块可以等到需要使用的时候才加载。 结合vue2中组件懒加载 代码级优化：1.JavaScript DOM​ 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。 2.避免回流和重绘 reflow repaint：频繁触发重绘和回流会导致UI频繁渲染​ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。当页面布局和几何属性改变时就需要回流 ​ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 ​ 回流必将引起重绘，而重绘不一定会引起回流。 触发页面重布局的属性： 盒子模型相关属性会触发重布局 ​ 定位属性及浮动也会触发重布局 ​ 改变节点内部文字结构也会触发重布局 优化： 用translate替代top改变 用opacity替代visibility 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择 对于动画新建图层 启用 GPU 硬件加速 将频繁重绘和回流的Dom元素单独作为一个独立图层，这个Dom元素的重绘和回流的影响只会在这个图层上 3.性能优化的具体方法（way）一）内容层面1、DNS解析优化（DNS缓存、减少DNS查找、keep-alive、适当的主机域名） 2、避免重定向（/还是需要的） 3、切分到多个域名 4、杜绝404 二）网络传输阶段1、减少传输过程中实体的大小 ​ 1）缓存 ​ 2）cookie优化 ​ 3）文件压缩（Accept-Encoding：g-zip） 2、减少请求的次数 ​ 1）文件适当的合并 ​ 2）雪碧图 3、异步加载（并发,requirejs） 4、预加载、延后加载、按需加载 三）渲染阶段1、js放底部，css放顶部 2、减少重绘和回流 ​ 3、合理使用Viewport 等meta头部 ​ 4、减少dom节点 ​ 5、BigPipe 四）脚本执行阶段1、缓存节点，尽量减少节点的查找 2、减少节点的操作（innerHTML） 3、避免无谓的循环，break、continue、return的适当使用 4、事件委托 4.高性能滚动优化及渲染优化网页生成的时候，至少会渲染（Layout+Paint）一次。用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）。其中，用户 scroll 和 resize 行为（即是滑动页面和改变窗口大小）会导致页面不断的重新渲染。 当滚动页面时，浏览器可能会需要绘制层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。 scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。 针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流。 防抖（Debouncing）防抖即是是在一定时间内，只在最后一次被触发时，执行处理函数。 12345678910111213141516// 简单的防抖动函数function debounce(func, wait, immediate) &#123; var timeout; // 定时器变量 return function() &#123;//闭包避免timeout变为全局变量 clearTimeout(timeout); // 每次触发 scroll handler 时先清除定时器 timeout = setTimeout(func, wait); // 指定 xx ms 后触发真正想进行的操作 handler &#125;;&#125;;// 实际想绑定在 scroll 事件上的 handlerfunction realFunc()&#123; console.log(&quot;Success&quot;);&#125;// 采用了防抖动window.addEventListener(&apos;scroll&apos;,debounce(realFunc,500));// 没采用防抖动window.addEventListener(&apos;scroll&apos;,realFunc);//scroll只要改变立即操作handler 封装防抖 123456789101112131415161718// 防抖动函数function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // 滚动中的真正的操作&#125;, 250);window.addEventListener(&apos;resize&apos;, myEfficientFn);// 绑定监听 节流（Throttling）防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。 这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。 节流函数，只允许一个函数在 X 毫秒内执行一次。 避免处理函数被频繁的触发，让函数每隔一段时间执行一次，当在执行周期内被触发时，不允许被执行。 当触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行，就这样。 与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。并且节流函数多了一个 mustRun 属性，代表 mustRun 毫秒内，必然会触发一次 handler ，同样是利用定时器。 123456789101112131415161718192021// 简单的节流函数function throttle(func, wait, mustRun) &#123; var timeout,startTime = new Date(); return function() &#123; var context = this,args = arguments,curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if(curTime - startTime &gt;= mustRun)&#123; func.apply(context,args);//触发handler startTime = curTime; &#125;else&#123;// 没达到触发间隔，重新设定定时器 timeout = setTimeout(func, wait); &#125; &#125;;&#125;;function realFunc()&#123;// 实际想绑定在 scroll 事件上的 handler console.log(&quot;Success&quot;); &#125;// 采用了节流函数window.addEventListener(&apos;scroll&apos;,throttle(realFunc,500,1000));//如果在一段时间内 scroll 触发的间隔一直小于500ms ，保证 handler 在 1000ms 内至少触发一次]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2018%2F12%2F20%2F%E6%AD%A3%E5%88%99%2F</url>
    <content type="text"><![CDATA[一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 基本元字符 . ： 匹配除了换行符之外的任何单个字符 \ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\*/ 将 ‘‘ 的特殊性移除，从而可以匹配像 `”a“` 这样的字符串。 | ： 逻辑或操作符 [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\这些字符都表示其本身 [^]：对上面一个集合取非 - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符 {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 * ： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。 位置元字符 ^ ： 单独使用匹配表达式的开始 \$ ： 匹配表达式的结束 \b：匹配单词边界 \B：匹配非单词边界 (?=p)：匹配 p 前面的位置 (?!p)：匹配不是 p 前面的位置 特殊元字符 \d：[0-9]，表示一位数字，记忆方式 digit \D：[^0-9]，表示一位非数字 \s：[\t\v\n\r\f]，表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），记忆方式 space character \S：[^\t\v\n\r\f]，表示非空白符 \w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word \W：[^0-9a-zA-Z]，表示非单词字符 标志字符 g : 全局搜索 记忆方式global i ：不区分大小写 记忆方式 ignore m ：多行搜索 在 js 中的使用支持正则的 String 对象的方法 searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 match接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果 12345678910var str = &apos;For more information, see Chapter 3.4.5.1&apos;;var re = /see (chapter \d+(\.\d)*)/i;var found = str.match(re);console.log(found);// (3) [&quot;see Chapter 3.4.5.1&quot;, &quot;Chapter 3.4.5.1&quot;, &quot;.1&quot;, index: 22, input: &quot;For more information, see Chapter 3.4.5.1&quot;]// &apos;see Chapter 3.4.5.1&apos; 是整个匹配。// &apos;Chapter 3.4.5.1&apos; 被&apos;(chapter \d+(\.\d)*)&apos;捕获。// &apos;.1&apos; 是被&apos;(\.\d)&apos;捕获的最后一个值。// &apos;index&apos; 属性(22) 是整个匹配从零开始的索引。// &apos;input&apos; 属性是被解析的原始字符串。复制代码 12345var str = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;;var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;] replace接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。 12345var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 123456function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);// newString abc - 12345 - #$*% split 接受两个参数，返回一个数组。第一个是用来分割字符串的字符或者正则，如果是空字符串则会将元字符串中的每个字符以数组形式返回，第二个参数可选作为限制分割多少个字符，也是返回的数组的长度限制。有一个地方需要注意，用捕获括号的时候会将匹配结果也包含在返回的数组中 123456789var myString = &quot;Hello 1 word. Sentence number 2.&quot;;var splits = myString.split(/\d/);console.log(splits);// [ &quot;Hello &quot;, &quot; word. Sentence number &quot;, &quot;.&quot; ]splits = myString.split(/(\d)/);console.log(splits);// [ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 正则对象的方法 test：接受一个字符串参数，如果正则表达式与指定的字符串匹配返回 true 否则返回 false exec：同样接受一个字符串为参数，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 匹配时，返回值跟 match 方法没有 g 标识时是一样的。数组第 0 个表示与正则相匹配的文本，后面 n 个是对应的 n 个捕获的文本，最后两个是对象 index 和 input 同时它会在正则实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把正则实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。 有没有 g 标识对单词执行 exec 方法是没有影响的，只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 123456789101112131415161718var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);console.log( regex2.exec(string) );console.log( regex2.lastIndex);// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]// =&gt; 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;]// =&gt; 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;]// =&gt; 10// =&gt; null// =&gt; 0 其中正则实例lastIndex属性，表示下一次匹配开始的位置。 比如第一次匹配了“2017”，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。 从上述代码看出，在使用exec时，经常需要配合使用while循环： 123456789var string = &quot;2017.06.27&quot;;var regex2 = /\b(\d+)\b/g;var result;while ( result = regex2.exec(string) ) &#123; console.log( result, regex2.lastIndex );&#125;// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;] 4// =&gt; [&quot;06&quot;, &quot;06&quot;, index: 5, input: &quot;2017.06.27&quot;] 7// =&gt; [&quot;27&quot;, &quot;27&quot;, index: 8, input: &quot;2017.06.27&quot;] 10 正则的匹配字符匹配精确匹配就不说了，比如/hello/，也只能匹配字符串中的”hello”这个子串。正则表达式之所以强大，是因为其能实现模糊匹配。 匹配多种数量用{m,n}来匹配多种数量，其他几种形式(+*?)都可以等价成这种。比如 123var regex = /ab&#123;2,5&#125;c/g;var string = &quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;;console.log( string.match(regex) ); // [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;] 贪婪和非贪婪: 默认贪婪 123var regex = /\d&#123;2,5&#125;/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;123&quot;, &quot;1234&quot;, &quot;12345&quot;, &quot;12345&quot;] 两次后面加一个 ？ 就可以表示非贪婪，非贪婪时 123var regex = /\d&#123;2,5&#125;?/g;var string = &quot;123 1234 12345 123456&quot;;console.log( string.match(regex) ); // [&quot;12&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;12&quot;, &quot;34&quot;, &quot;56&quot;] 匹配多种情况用字符组[]来匹配多种情况，其他几种形式(\d\D\s\S\w\W)都可以等价成这种。比如 123var regex = /a[123]b/g;var string = &quot;a0b a1b a2b a3b a4b&quot;;console.log( string.match(regex) ); // [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;] 如果字符组里面字符特别多的话可以用-来表示范围，比如[123456abcdefGHIJKLM]，可以写成[1-6a-fG-M]，用[^0-9]表示非除了数字以外的字符多种情况还可以是多种分支，用管道符来连接|，比如 123var regex = /good|goodbye/g;var string = &quot;goodbye&quot;;console.log( string.match(regex) ); // [&quot;good&quot;] 这个例子可以看出分支结构也是惰性的，匹配到了就不再往后尝试了。 例子掌握这两种方式就可以解决比较简单的正则问题了。 匹配保留2位小数的数字/^([1-9]\d*|0)(\.\d{1,2})?$/ 电话号码/(\+86)?1\d{10}/ 身份证/^(\d{15}|\d{17}([xX]|\d))$/ 位置匹配什么是位置位置是相邻字符之间的，比如，有一个字符串 hello ，这个字符串一共有6个位置 *h*e*l*l*o*， *代表位置 ^，$ 匹配字符的开头和结尾，比如/^hello$/ 匹配一个字符串，要符合这样的条件，字符串开头的位置，紧接着是 h 然后是 e,l,l,o 最后是字符串结尾的位置位置还可以被替换成字符串，比如&#39;hello&#39;.replace(/^|$/g, &#39;#&#39;) 结果是 #hello# /b，/B 匹配单词边界和非单词边界，单词边界具体指 \w([a-zA-Z0-9_]) 和 \W 之间的位置，包括 \w 和 ^ 以及 $ 之间的位置，比如&#39;hello word [js]_reg.exp-01&#39;.replace(/\b/g, &#39;#&#39;) 结果是 #hello# #word# [#js#]#_reg#.#exp#-#01# (?=p)，(?!p) 匹配 p 前面的位置和不是 p 前面位置，比如&#39;hello&#39;.replace(/(?=l)/g, &#39;#&#39;) 结果是 he#l#lo&#39;hello&#39;.replace(/(?!l)/g, &#39;#&#39;) 结果是 #h#ell#o# 位置的特性字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 ‘’，比如hello 可以是一般的 &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，也可以是 &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;&#39; + &#39;h&#39; + &#39;e&#39; + &#39;l&#39; + &#39;l&#39; + &#39;o&#39; + &#39;&#39;，所以/^h\Be\Bl\Bl\Bo$/.test(&#39;hello&#39;) 结果是 true，/^^^h\B\B\Be\Bl\Bl\Bo$$$/.test(&#39;hello&#39;) 结果也是 true 例子：千分位，将 123123123 转换成 123,123,123数字是从后往前数，也就是以一个或者多个3位数字结尾的位置换成 ‘,’ 就好了，写成正则就是123123213.replace(/(?=(\d{3})+$)/g, &#39;,&#39;) 但是这样的话会在最前面也加一个 ‘,’ 这明显是不对的。所以还得继续改一下正则要求匹配到的位置不是开头，可以用 /(?!^)(?=(\d{3})+$)/g 来表示。换种思路来想，能不能是以数字开头然后加上上面的条件呢，得出这个正则 /\d(?=(\d{3})+$)/g，但是这个正则匹配的结果是 12,12,123，发现这个正则匹配的不是位置而是字符，将数字换成了 ‘,’ 可以得出结论，如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置。 分组：主要是括号的使用分组和分支结构在分支结构中，括号是用来表示一个整体的，(p1|p2)，比如要匹配下面的字符串 12I love JavaScriptI love Regular Expression 可以用正则/^I love (JavaScript|Regular Expression)$/ 而不是 /^I love JavaScript|Regular Expression$/表示一个整体还比如 /(abc)+/ 一个或者多个 abc 字符串上面这些使用 () 包起来的地方就叫做分组 12&apos;I love JavaScript&apos;.match(/^I love (JavaScript|Regular Expression)$/)// [&quot;I love JavaScript&quot;, &quot;JavaScript&quot;, index: 0, input: &quot;I love JavaScript&quot;] 输出的数组第二个元素，”JavaScript” 就是分组匹配到的内容 引用分组提取数据比如我们要用正则来匹配一个日期格式，yyyy-mm-dd，可以写出简单的正则/\d{4}-\d{2}-\d{2}/，这个正则还可以改成分组形式的/(\d{4})-(\d{2})-(\d{2})/这样我们可以分别提取出一个日期的年月日，用 String 的 match 方法或者用正则的 exec 方法都可以 1234var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;console.log( string.match(regex) ); // =&gt; [&quot;2017-08-09&quot;, &quot;2017&quot;, &quot;08&quot;, &quot;09&quot;, index: 0, input: &quot;2017-08-09&quot;] 捕获组编号：按照普通捕获组中“(”出现的先后顺序，从左到右，从1开始进行编号 也可以用正则对象构造函数的全局属性 $1 - $9 来获取 12345678910var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;regex.test(string); // 正则操作即可，例如//regex.exec(string);//string.match(regex);console.log(RegExp.$1); // &quot;2017&quot;console.log(RegExp.$2); // &quot;08&quot;console.log(RegExp.$3); // &quot;09&quot; 替换如果想要把 yyyy-mm-dd 替换成格式 mm/dd/yyyy 应该怎么做。String 的 replace 方法在第二个参数里面可以用 $1 - $9 来指代相应的分组 12345678910111213141516var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, &quot;$2/$3/$1&quot;);console.log(result); // &quot;08/09/2017&quot;等价var result = string.replace(regex, function() &#123; return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;&#125;);console.log(result); // &quot;08/09/2017&quot;等价var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = &quot;2017-08-09&quot;;var result = string.replace(regex, function(match, year, month, day) &#123; return month + &quot;/&quot; + day + &quot;/&quot; + year;&#125;);console.log(result); // &quot;08/09/2017&quot; 反向引用捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 反向引用的作用通常是用来查找或限定重复，限定指定标识配对出现等等。 对于普通捕获组语法如下：JavaScript不支持命名捕获组,所以对于捕获组的引用就只支持普通捕获组的反向引用和$number方式的引用. 普通捕获组反向引用：\k&lt;number&gt;，通常简写为\number。number是十进制的数字，即捕获组的编号。 1234//替换掉html标签中的属性 var data = &quot;&lt;table id=\&quot;test\&quot;&gt;&lt;tr class=\&quot;light\&quot;&gt;&lt;td&gt; test &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;var reg = /&lt;([a-z]+)[^&gt;]*&gt;/ig;console.log(data.replace(reg, &quot;&lt;$1&gt;&quot;)); //replace中使用 之前匹配日期的正则在使用的时候发现还有另外两种写法，一共三种 1232017-08-092017/08/092017.08.09 要匹配这三种应该怎么写正则，第一反应肯定是把上面那个正则改一下/(\d{4})[-/.](\d{2})[-/.](\d{2})/，把 - 改成 [-/.] 这三种都可以看上去没问题，我们多想想就会发现，这个正则把 2017-08.09 这种字符串也匹配到了，这个肯定是不符合预期的。这个时候我们就需要用到反向引用了，反向引用可以在匹配阶段捕获到分组的内容 /(\d{4})([-/.])(\d{2})\2(\d{2})/ 那么出现括号嵌套怎么办，比如1234567var regex = /^((\d)(\d(\d)))\1\2\3\4$/;var string = &quot;1231231233&quot;;console.log( regex.test(string) ); // trueconsole.log( RegExp.$1 ); // 123console.log( RegExp.$2 ); // 1console.log( RegExp.$3 ); // 23console.log( RegExp.$4 ); // 3 嵌套的括号以左括号为准 引用了不存在的分组呢如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\1就匹配\1 非捕获分组我们有时候只是想用括号原本的功能而不想捕获他们。这个时候可以用(?:p)表示一个非捕获分组 例子 驼峰改短横 123function dash(str) &#123;return str.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();&#125; 获取链接的 search 值链接：https://www.baidu.com?name=jawil&amp;age=23 12345678function getParamName(attr) &#123;let match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search)//[&quot;?name=jawil&quot;, &quot;jawil&quot;, index: 0, input: &quot;?name=jawil&amp;age=23&quot;]return match &amp;&amp; decodeURIComponent(match[1].replace(/\+/g, &apos; &apos;)) // url中+号表示空格,要替换掉&#125;console.log(getParamName(&apos;name&apos;)) // &quot;jawil&quot; 去掉字符串前后的空格 123function trim(str) &#123; return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;)&#125; 判断一个数是否是质数 123function isPrime(num) &#123;return !/^1?$|^(11+?)\1+$/.test(Array(num+1).join(&apos;1&apos;))&#125; 这里首先是把一个数字变成1组成的字符串，比如11就是 ‘1111111111’ 11个1 然后正则分两部分，第一部分是匹配空字符串或者1,第二部分是先匹配两个或者多个1，非贪婪模式，那么先会匹配两个1，然后将匹配的两个1分组，后面就是匹配一个或者多个’2个1’，就相当于整除2，如果匹配成功就证明不是质数，如果不成功就会匹配3个1，然后匹配多个3个1，相当于整除3，这样一直下去会一直整除到自己本身。如果还是不行就证明这个数字是质数。 回溯正则是怎么匹配的有这么一个字符串 ‘abbbc’ 和这么一个正则 /ab{1,3}bbc//ab{1,3}bbc/.test(&#39;abbbc&#39;) 我们一眼可以看出来是 true，但是 JavaScript 是怎么匹配的呢 回溯例如我们上面的例子，回溯的思想是，从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法” 贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个分支结构也会产生回溯，比如/^(test|te)sts$/.test(&#39;tests&#39;) 前面括号里面的匹配过程是先匹配到 test 然后继续往后匹配匹配到字符 s 的时候还是成功的，匹配到 st 的时候发现不能匹配， 所以会回到前面的分支结构的其他分支继续匹配，如果不行的话再换其他分支。 读正则结构和操作符结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。操作符： 转义符 \ 括号和方括号 (…)、(?:…)、(?=…)、(?!…)、[…] 量词限定符 {m}、{m,n}、{m,}、?、*、+ 位置和序列 ^ 、$、 \元字符、 一般字符 管道符（竖杠） | 操作符的优先级是从上到下，由高到低的，所以在分析正则的时候可以根据优先级来拆分正则，比如/ab?(c|de*)+|fg/ 因为括号是一个整体，所以/ab?()+|fg/,括号里面具体是什么可以放到后面再分析 根据量词和管道符的优先级，所以a, b?, ()+和管道符后面的f, g 同理分析括号里面的c|de* =&gt; c和d, e* 综上，这个正则描述的是]]></content>
  </entry>
</search>
